{"version":3,"file":"markermanager.umd.js","sources":["../src/gridbounds.ts","../src/markermanager.ts","../src/utils.ts"],"sourcesContent":["/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Helper class to create a bounds of INT ranges.\n * @ignore\n */\nexport class GridBounds {\n  public z: number;\n  public minX: number;\n  public maxX: number;\n  public minY: number;\n  public maxY: number;\n\n  /**\n   *\n   * @param bounds\n   * @param z\n   */\n  constructor(bounds: google.maps.Point[], z: number) {\n    // [sw, ne]\n    this.z = z;\n    this.minX = Math.min(bounds[0].x, bounds[1].x);\n    this.maxX = Math.max(bounds[0].x, bounds[1].x);\n    this.minY = Math.min(bounds[0].y, bounds[1].y);\n    this.maxY = Math.max(bounds[0].y, bounds[1].y);\n  }\n\n  /**\n   * Returns true if this bounds equal the given bounds.\n   * @param {GridBounds} gridBounds GridBounds The bounds to test.\n   * @return {Boolean} This Bounds equals the given GridBounds.\n   */\n  equals(gridBounds: GridBounds): boolean {\n    if (\n      this.maxX === gridBounds.maxX &&\n      this.maxY === gridBounds.maxY &&\n      this.minX === gridBounds.minX &&\n      this.minY === gridBounds.minY\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Returns true if this bounds (inclusively) contains the given point.\n   * @param {Point} point  The point to test.\n   * @return {Boolean} This Bounds contains the given Point.\n   */\n  containsPoint(point: google.maps.Point): boolean {\n    return (\n      this.minX <= point.x &&\n      this.maxX >= point.x &&\n      this.minY <= point.y &&\n      this.maxY >= point.y\n    );\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/// <reference types=\"@types/googlemaps\" />\n\nimport { latLngToPixel } from \"./utils\";\nimport { GridBounds } from \"./gridbounds\";\n\ninterface Options {\n  maxZoom?: number;\n  shown?: boolean;\n  trackMarkers?: boolean;\n  borderPadding?: number;\n}\n\n/**\n * Creates a new MarkerManager that will show/hide markers on a map.\n */\nclass MarkerManager {\n  public shown: boolean;\n  public shownMarkers: number;\n\n  private _map: google.maps.Map;\n  private _mapZoom: number;\n  private _maxZoom: number;\n  private _tileSize = 1024;\n  private _trackMarkers: boolean;\n  private _swPadding: google.maps.Size;\n  private _nePadding: google.maps.Size;\n  private _gridWidth: { [k: string]: number };\n  private _grid: google.maps.Marker[][][][];\n  private _numMarkers: { [k: string]: number };\n  private _shownBounds: GridBounds;\n\n  /**\n   * @constructor\n   * @param map The map to manage.\n   * @param {Options} options\n   */\n  constructor(\n    map: google.maps.Map,\n    { maxZoom = 19, trackMarkers, shown = true, borderPadding = 100 }: Options\n  ) {\n    this._map = map;\n    this._mapZoom = map.getZoom();\n    this._maxZoom = maxZoom;\n    this._trackMarkers = trackMarkers;\n\n    // The padding in pixels beyond the viewport, where we will pre-load markers.\n    this._swPadding = new google.maps.Size(-borderPadding, borderPadding);\n    this._nePadding = new google.maps.Size(borderPadding, -borderPadding);\n\n    this._gridWidth = {};\n    this._grid = [];\n    this._grid[this._maxZoom] = [];\n    this._numMarkers = {};\n    this._numMarkers[this._maxZoom] = 0;\n\n    this.shownMarkers = 0;\n    this.shown = shown;\n\n    google.maps.event.addListenerOnce(map, \"idle\", () => {\n      this._initialize();\n    });\n  }\n\n  private _initialize(): void {\n    const mapTypes = this._map.mapTypes;\n\n    // Find max zoom level\n    let mapMaxZoom = 1;\n    for (const sType in mapTypes) {\n      if (\n        sType in mapTypes &&\n        mapTypes.get(sType) &&\n        mapTypes.get(sType).maxZoom === \"number\"\n      ) {\n        const mapTypeMaxZoom = this._map.mapTypes.get(sType).maxZoom;\n        if (mapTypeMaxZoom > mapMaxZoom) {\n          mapMaxZoom = mapTypeMaxZoom;\n        }\n      }\n    }\n\n    google.maps.event.addListener(\n      this._map,\n      \"dragend\",\n      this._onMapMoveEnd.bind(this)\n    );\n\n    google.maps.event.addListener(\n      this._map,\n      \"idle\",\n      this._onMapMoveEnd.bind(this)\n    );\n\n    google.maps.event.addListener(\n      this._map,\n      \"zoom_changed\",\n      this._onMapMoveEnd.bind(this)\n    );\n\n    this.resetManager();\n\n    this._shownBounds = this._getMapGridBounds();\n\n    google.maps.event.trigger(this, \"loaded\");\n  }\n  /**\n   * This closure provide easy access to the map.\n   * They are used as callbacks, not as methods.\n   * @param marker Marker to be removed from the map\n   */\n  private _removeOverlay(marker: google.maps.Marker): void {\n    marker.setMap(null);\n    this.shownMarkers--;\n  }\n\n  /**\n   * This closure provide easy access to the map.\n   * They are used as callbacks, not as methods.\n   * @param marker Marker to be added to the map\n   */\n  private _addOverlay(marker: google.maps.Marker): void {\n    if (this.shown) {\n      marker.setMap(this._map);\n      this.shownMarkers++;\n    }\n  }\n\n  /**\n   * Initializes MarkerManager arrays for all zoom levels\n   * Called by constructor and by clearAllMarkers\n   */\n  public resetManager(): void {\n    let mapWidth = 256;\n    for (let zoom = 0; zoom <= this._maxZoom; ++zoom) {\n      this._grid[zoom] = [];\n      this._numMarkers[zoom] = 0;\n      this._gridWidth[zoom] = Math.ceil(mapWidth / this._tileSize);\n      mapWidth <<= 1;\n    }\n  }\n\n  /**\n   * Removes all markers in the manager, and\n   * removes any visible markers from the map.\n   */\n  public clearMarkers(): void {\n    this._processAll(this._shownBounds, this._removeOverlay.bind(this));\n    this.resetManager();\n  }\n\n  /**\n   * Gets the tile coordinate for a given latlng point.\n   *\n   * @param {LatLng} latlng The geographical point.\n   * @param {Number} zoom The zoom level.\n   * @param {google.maps.Size} padding The padding used to shift the pixel coordinate.\n   *               Used for expanding a bounds to include an extra padding\n   *               of pixels surrounding the bounds.\n   * @return {GPoint} The point in tile coordinates.\n   *\n   */\n  private _getTilePoint(\n    latlng: google.maps.LatLng,\n    zoom: number,\n    padding: google.maps.Size\n  ): google.maps.Point {\n    const pixelPoint = latLngToPixel(latlng, zoom);\n\n    const point = new google.maps.Point(\n      Math.floor((pixelPoint.x + padding.width) / this._tileSize),\n      Math.floor((pixelPoint.y + padding.height) / this._tileSize)\n    );\n\n    return point;\n  }\n\n  /**\n   * Finds the appropriate place to add the marker to the grid.\n   * Optimized for speed; does not actually add the marker to the map.\n   * Designed for batch-_processing thousands of markers.\n   *\n   * @param {Marker} marker The marker to add.\n   * @param {Number} minZoom The minimum zoom for displaying the marker.\n   * @param {Number} maxZoom The maximum zoom for displaying the marker.\n   */\n  private _addMarkerBatch(\n    marker: google.maps.Marker,\n    minZoom: number,\n    maxZoom: number\n  ): void {\n    const mPoint = marker.getPosition();\n    marker.set(\"__minZoom\", minZoom);\n\n    // Tracking markers is expensive, so we do this only if the\n    // user explicitly requested it when creating marker manager.\n    if (this._trackMarkers) {\n      google.maps.event.addListener(marker, \"changed\", function(a, b, c) {\n        this._onMarkerMoved(a, b, c);\n      });\n    }\n\n    const gridPoint = this._getTilePoint(\n      mPoint,\n      maxZoom,\n      new google.maps.Size(0, 0)\n    );\n\n    for (let zoom = maxZoom; zoom >= minZoom; zoom--) {\n      const cell = this._getGridCellCreate(gridPoint.x, gridPoint.y, zoom);\n      cell.push(marker);\n\n      gridPoint.x = gridPoint.x >> 1;\n      gridPoint.y = gridPoint.y >> 1;\n    }\n  }\n\n  /**\n   * Returns whether or not the given point is visible in the shown bounds. This\n   * is a helper method that takes care of the corner case, when shownBounds have\n   * negative minX value.\n   *\n   * @param {Point} point a point on a grid.\n   * @return {Boolean} Whether or not the given point is visible in the currently\n   * shown bounds.\n   */\n  private _isGridPointVisible(point: google.maps.Point): boolean {\n    const vertical =\n      this._shownBounds.minY <= point.y && point.y <= this._shownBounds.maxY;\n    const minX = this._shownBounds.minX;\n    let horizontal = minX <= point.x && point.x <= this._shownBounds.maxX;\n    if (!horizontal && minX < 0) {\n      // Shifts the negative part of the rectangle. As point.x is always less\n      // than grid width, only test shifted minX .. 0 part of the shown bounds.\n      const width = this._gridWidth[this._shownBounds.z];\n      horizontal = minX + width <= point.x && point.x <= width - 1;\n    }\n    return vertical && horizontal;\n  }\n\n  /**\n   * Reacts to a notification from a marker that it has moved to a new location.\n   * It scans the grid all all zoom levels and moves the marker from the old grid\n   * location to a new grid location.\n   *\n   * @param {Marker} marker The marker that moved.\n   * @param {LatLng} oldPoint The old position of the marker.\n   * @param {LatLng} newPoint The new position of the marker.\n   */\n  private _onMarkerMoved(\n    marker: google.maps.Marker,\n    oldPoint: google.maps.LatLng,\n    newPoint: google.maps.LatLng\n  ): void {\n    // NOTE: We do not know the minimum or maximum zoom the marker was\n    // added at, so we start at the absolute maximum. Whenever we successfully\n    // remove a marker at a given zoom, we add it at the new grid coordinates.\n    let zoom = this._maxZoom;\n    let changed = false;\n    const oldGrid = this._getTilePoint(\n      oldPoint,\n      zoom,\n      new google.maps.Size(0, 0)\n    );\n    const newGrid = this._getTilePoint(\n      newPoint,\n      zoom,\n      new google.maps.Size(0, 0)\n    );\n    while (zoom >= 0 && (oldGrid.x !== newGrid.x || oldGrid.y !== newGrid.y)) {\n      const cell = this._getGridCellNoCreate(oldGrid.x, oldGrid.y, zoom);\n      if (cell) {\n        if (this._removeMarkerFromCell(cell, marker)) {\n          this._getGridCellCreate(newGrid.x, newGrid.y, zoom).push(marker);\n        }\n      }\n      // For the current zoom we also need to update the map. Markers that no\n      // longer are visible are removed from the map. Markers that moved into\n      // the shown bounds are added to the map. This also lets us keep the count\n      // of visible markers up to date.\n      if (zoom === this._mapZoom) {\n        if (this._isGridPointVisible(oldGrid)) {\n          if (!this._isGridPointVisible(newGrid)) {\n            this._removeOverlay(marker);\n            changed = true;\n          }\n        } else {\n          if (this._isGridPointVisible(newGrid)) {\n            this._addOverlay(marker);\n            changed = true;\n          }\n        }\n      }\n      oldGrid.x = oldGrid.x >> 1;\n      oldGrid.y = oldGrid.y >> 1;\n      newGrid.x = newGrid.x >> 1;\n      newGrid.y = newGrid.y >> 1;\n      --zoom;\n    }\n    if (changed) {\n      this._notifyListeners();\n    }\n  }\n\n  /**\n   * Removes marker from the manager and from the map\n   * (if it's currently visible).\n   * @param {GMarker} marker The marker to delete.\n   */\n  public removeMarker(marker: google.maps.Marker): void {\n    let zoom = this._maxZoom;\n    let changed = false;\n    const point = marker.getPosition();\n    const grid = this._getTilePoint(point, zoom, new google.maps.Size(0, 0));\n    while (zoom >= 0) {\n      const cell = this._getGridCellNoCreate(grid.x, grid.y, zoom);\n\n      if (cell) {\n        this._removeMarkerFromCell(cell, marker);\n      }\n      // For the current zoom we also need to update the map. Markers that no\n      // longer are visible are removed from the map. This also lets us keep the count\n      // of visible markers up to date.\n      if (zoom === this._mapZoom) {\n        if (this._isGridPointVisible(grid)) {\n          this._removeOverlay(marker);\n          changed = true;\n        }\n      }\n      grid.x = grid.x >> 1;\n      grid.y = grid.y >> 1;\n      --zoom;\n    }\n    if (changed) {\n      this._notifyListeners();\n    }\n    this._numMarkers[marker.get(\"__minZoom\")]--;\n  }\n\n  /**\n   * Add many markers at once.\n   * Does not actually update the map, just the internal grid.\n   *\n   * @param {Array of Marker} markers The markers to add.\n   * @param {Number} minZoom The minimum zoom level to display the markers.\n   * @param {Number} maxZoom The maximum zoom level to display the markers.\n   */\n  public addMarkers(\n    markers: google.maps.Marker[],\n    minZoom: number,\n    maxZoom: number\n  ): void {\n    maxZoom = this._getOptmaxZoom(maxZoom);\n    for (let i = markers.length - 1; i >= 0; i--) {\n      this._addMarkerBatch(markers[i], minZoom, maxZoom);\n    }\n\n    this._numMarkers[minZoom] += markers.length;\n  }\n\n  /**\n   * Returns the value of the optional maximum zoom. This method is defined so\n   * that we have just one place where optional maximum zoom is calculated.\n   *\n   * @param {Number} maxZoom The optinal maximum zoom.\n   * @return The maximum zoom.\n   */\n  private _getOptmaxZoom(maxZoom: number): number {\n    return maxZoom || this._maxZoom;\n  }\n\n  /**\n   * Calculates the total number of markers potentially visible at a given\n   * zoom level.\n   *\n   * @param {Number} zoom The zoom level to check.\n   */\n  public getMarkerCount(zoom: number): number {\n    let total = 0;\n    for (let z = 0; z <= zoom; z++) {\n      total += this._numMarkers[z];\n    }\n    return total;\n  }\n\n  /**\n   * Returns a marker given latitude, longitude and zoom. If the marker does not\n   * exist, the method will return a new marker. If a new marker is created,\n   * it will NOT be added to the manager.\n   *\n   * @param {Number} lat - the latitude of a marker.\n   * @param {Number} lng - the longitude of a marker.\n   * @param {Number} zoom - the zoom level\n   * @return {GMarker} marker - the marker found at lat and lng\n   */\n  public getMarker(lat: number, lng: number, zoom: number): google.maps.Marker {\n    const mPoint = new google.maps.LatLng(lat, lng);\n    const gridPoint = this._getTilePoint(\n      mPoint,\n      zoom,\n      new google.maps.Size(0, 0)\n    );\n\n    let marker = new google.maps.Marker({ position: mPoint });\n\n    const cell = this._getGridCellNoCreate(gridPoint.x, gridPoint.y, zoom);\n    if (cell !== undefined) {\n      for (let i = 0; i < cell.length; i++) {\n        if (\n          lat === cell[i].getPosition().lat() &&\n          lng === cell[i].getPosition().lng()\n        ) {\n          marker = cell[i];\n        }\n      }\n    }\n    return marker;\n  }\n\n  /**\n   * Add a single marker to the map.\n   *\n   * @param {Marker} marker The marker to add.\n   * @param {Number} minZoom The minimum zoom level to display the marker.\n   * @param {Number} maxZoom The maximum zoom level to display the marker.\n   */\n  public addMarker(\n    marker: google.maps.Marker,\n    minZoom: number,\n    maxZoom: number\n  ): void {\n    maxZoom = this._getOptmaxZoom(maxZoom);\n    this._addMarkerBatch(marker, minZoom, maxZoom);\n    const gridPoint = this._getTilePoint(\n      marker.getPosition(),\n      this._mapZoom,\n      new google.maps.Size(0, 0)\n    );\n    if (\n      this._isGridPointVisible(gridPoint) &&\n      minZoom <= this._shownBounds.z &&\n      this._shownBounds.z <= maxZoom\n    ) {\n      this._addOverlay(marker);\n      this._notifyListeners();\n    }\n    this._numMarkers[minZoom]++;\n  }\n\n  /**\n   * Get a cell in the grid, creating it first if necessary.\n   *\n   * Optimization candidate\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   * @return {Array} The cell in the array.\n   */\n  private _getGridCellCreate(\n    x: number,\n    y: number,\n    z: number\n  ): google.maps.Marker[] {\n    // TODO(jpoehnelt) document this\n    if (x < 0) {\n      x += this._gridWidth[z];\n    }\n\n    if (!this._grid[z]) {\n      this._grid[z] = [];\n    }\n    if (!this._grid[z][x]) {\n      this._grid[z][x] = [];\n    }\n    if (!this._grid[z][x][y]) {\n      this._grid[z][x][y] = [];\n    }\n    return this._grid[z][x][y];\n  }\n\n  /**\n   * Get a cell in the grid, returning undefined if it does not exist.\n   *\n   * NOTE: Optimized for speed -- otherwise could combine with _getGridCellCreate.\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   * @return {Array} The cell in the array.\n   */\n  private _getGridCellNoCreate(\n    x: number,\n    y: number,\n    z: number\n  ): google.maps.Marker[] | null {\n    if (x < 0) {\n      x += this._gridWidth[z];\n    }\n\n    if (!this._grid[z]) {\n      return null;\n    }\n    if (!this._grid[z][x]) {\n      return null;\n    }\n    if (!this._grid[z][x][y]) {\n      return null;\n    }\n    return this._grid[z][x][y];\n  }\n\n  /**\n   * Turns at geographical bounds into a grid-space bounds.\n   *\n   * @param {LatLngBounds} bounds The geographical bounds.\n   * @param {Number} zoom The zoom level of the bounds.\n   * @param {google.maps.Size} swPadding The padding in pixels to extend beyond the\n   * given bounds.\n   * @param {google.maps.Size} nePadding The padding in pixels to extend beyond the\n   * given bounds.\n   * @return {GridBounds} The bounds in grid space.\n   */\n  private _getGridBounds(\n    bounds: google.maps.LatLngBounds,\n    zoom: number,\n    swPadding: google.maps.Size,\n    nePadding: google.maps.Size\n  ): GridBounds {\n    zoom = Math.min(zoom, this._maxZoom);\n\n    const bl = bounds.getSouthWest();\n    const tr = bounds.getNorthEast();\n    const sw = this._getTilePoint(bl, zoom, swPadding);\n\n    const ne = this._getTilePoint(tr, zoom, nePadding);\n    const gw = this._gridWidth[zoom];\n\n    // Crossing the prime meridian requires correction of bounds.\n    if (tr.lng() < bl.lng() || ne.x < sw.x) {\n      sw.x -= gw;\n    }\n    if (ne.x - sw.x + 1 >= gw) {\n      // Computed grid bounds are larger than the world; truncate.\n      sw.x = 0;\n      ne.x = gw - 1;\n    }\n\n    const gridBounds = new GridBounds([sw, ne], zoom);\n    gridBounds.z = zoom;\n\n    return gridBounds;\n  }\n\n  /**\n   * Gets the grid-space bounds for the current map viewport.\n   *\n   * @return {Bounds} The bounds in grid space.\n   */\n  private _getMapGridBounds(): GridBounds {\n    return this._getGridBounds(\n      this._map.getBounds(),\n      this._mapZoom,\n      this._swPadding,\n      this._nePadding\n    );\n  }\n\n  /**\n   * Event listener for map:movend.\n   * NOTE: Use a timeout so that the user is not blocked\n   * from moving the map.\n   *\n   * Removed this because a a lack of a scopy override/callback function on events.\n   */\n  private _onMapMoveEnd(): void {\n    window.setTimeout(this._updateMarkers.bind(this), 0);\n  }\n\n  /**\n   * Is this layer visible?\n   *\n   * Returns visibility setting\n   *\n   * @return {Boolean} Visible\n   */\n  public visible(): boolean {\n    return this.shown ? true : false;\n  }\n\n  /**\n   * Returns true if the manager is hidden.\n   * Otherwise returns false.\n   * @return {Boolean} Hidden\n   */\n  public isHidden(): boolean {\n    return !this.shown;\n  }\n\n  /**\n   * Shows the manager if it's currently hidden.\n   */\n  public show(): void {\n    this.shown = true;\n    this.refresh();\n  }\n\n  /**\n   * Hides the manager if it's currently visible\n   */\n  public hide(): void {\n    this.shown = false;\n    this.refresh();\n  }\n\n  /**\n   * Toggles the visibility of the manager.\n   */\n  public toggle(): void {\n    this.shown = !this.shown;\n    this.refresh();\n  }\n\n  /**\n   * Refresh forces the marker-manager into a good state.\n   * <ol>\n   *   <li>If never before initialized, shows all the markers.</li>\n   *   <li>If previously initialized, removes and re-adds all markers.</li>\n   * </ol>\n   */\n  public refresh(): void {\n    if (this.shownMarkers > 0) {\n      this._processAll(this._shownBounds, this._removeOverlay.bind(this));\n    }\n    // An extra check on this.show to increase performance (no need to _processAll_)\n    if (this.show) {\n      this._processAll(this._shownBounds, this._addOverlay.bind(this));\n    }\n    this._notifyListeners();\n  }\n\n  /**\n   * After the viewport may have changed, add or remove markers as needed.\n   */\n  private _updateMarkers(): void {\n    this._mapZoom = this._map.getZoom();\n    const newBounds = this._getMapGridBounds();\n\n    // If the move does not include new grid sections,\n    // we have no work to do:\n    if (\n      newBounds.equals(this._shownBounds) &&\n      newBounds.z === this._shownBounds.z\n    ) {\n      return;\n    }\n\n    if (newBounds.z !== this._shownBounds.z) {\n      this._processAll(this._shownBounds, this._removeOverlay.bind(this));\n      if (this.show) {\n        // performance\n        this._processAll(newBounds, this._addOverlay.bind(this));\n      }\n    } else {\n      // Remove markers:\n      this._rectangleDiff(\n        this._shownBounds,\n        newBounds,\n        this._removeCellMarkers.bind(this)\n      );\n\n      // Add markers:\n      if (this.show) {\n        // performance\n        this._rectangleDiff(\n          newBounds,\n          this._shownBounds,\n          this._addCellMarkers.bind(this)\n        );\n      }\n    }\n    this._shownBounds = newBounds;\n\n    this._notifyListeners();\n  }\n\n  /**\n   * Notify listeners when the state of what is displayed changes.\n   */\n  private _notifyListeners(): void {\n    google.maps.event.trigger(\n      this,\n      \"changed\",\n      this._shownBounds,\n      this.shownMarkers\n    );\n  }\n\n  /**\n   * Process all markers in the bounds provided, using a callback.\n   *\n   * @param {Bounds} bounds The bounds in grid space.\n   * @param {Function} callback The function to call for each marker.\n   */\n  private _processAll(\n    bounds: GridBounds,\n    callback: (marker: google.maps.Marker) => void\n  ): void {\n    for (let x = bounds.minX; x <= bounds.maxX; x++) {\n      for (let y = bounds.minY; y <= bounds.maxY; y++) {\n        this._processCellMarkers(x, y, bounds.z, callback);\n      }\n    }\n  }\n\n  /**\n   * Process all markers in the grid cell, using a callback.\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   * @param {Function} callback The function to call for each marker.\n   */\n  private _processCellMarkers(\n    x: number,\n    y: number,\n    z: number,\n    callback: (marker: google.maps.Marker) => void\n  ): void {\n    const cell = this._getGridCellNoCreate(x, y, z);\n    if (cell) {\n      for (let i = cell.length - 1; i >= 0; i--) {\n        callback(cell[i]);\n      }\n    }\n  }\n\n  /**\n   * Remove all markers in a grid cell.\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   */\n  private _removeCellMarkers(x: number, y: number, z: number): void {\n    this._processCellMarkers(x, y, z, this._removeOverlay.bind(this));\n  }\n\n  /**\n   * Add all markers in a grid cell.\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   */\n  private _addCellMarkers(x: number, y: number, z: number): void {\n    this._processCellMarkers(x, y, z, this._addOverlay.bind(this));\n  }\n\n  /**\n   * Use the _rectangleDiffCoords function to process all grid cells\n   * that are in bounds1 but not bounds2, using a callback, and using\n   * the current MarkerManager object as the instance.\n   *\n   * Pass the z parameter to the callback in addition to x and y.\n   *\n   * @param {Bounds} bounds1 The bounds of all points we may _process.\n   * @param {Bounds} bounds2 The bounds of points to exclude.\n   * @param {Function} callback The callback function to call\n   *                   for each grid coordinate (x, y, z).\n   */\n  private _rectangleDiff(\n    bounds1: GridBounds,\n    bounds2: GridBounds,\n    callback: (x: number, y: number, z: number) => void\n  ): void {\n    this._rectangleDiffCoords(bounds1, bounds2, function(x, y) {\n      callback(x, y, bounds1.z);\n    });\n  }\n\n  /**\n   * Calls the function for all points in bounds1, not in bounds2\n   *\n   * @param {Bounds} bounds1 The bounds of all points we may process.\n   * @param {Bounds} bounds2 The bounds of points to exclude.\n   * @param {Function} callback The callback function to call\n   *                   for each grid coordinate.\n   */\n  private _rectangleDiffCoords(\n    bounds1: GridBounds,\n    bounds2: GridBounds,\n    callback: (x: number, y: number) => void\n  ): void {\n    const minX1 = bounds1.minX;\n    const minY1 = bounds1.minY;\n    const maxX1 = bounds1.maxX;\n    const maxY1 = bounds1.maxY;\n    const minX2 = bounds2.minX;\n    const minY2 = bounds2.minY;\n    const maxX2 = bounds2.maxX;\n    const maxY2 = bounds2.maxY;\n\n    let x, y;\n    for (x = minX1; x <= maxX1; x++) {\n      // All x in R1\n      // All above:\n      for (y = minY1; y <= maxY1 && y < minY2; y++) {\n        // y in R1 above R2\n        callback(x, y);\n      }\n      // All below:\n      for (\n        y = Math.max(maxY2 + 1, minY1); // y in R1 below R2\n        y <= maxY1;\n        y++\n      ) {\n        callback(x, y);\n      }\n    }\n\n    for (y = Math.max(minY1, minY2); y <= Math.min(maxY1, maxY2); y++) {\n      // All y in R2 and in R1\n      // Strictly left:\n      for (x = Math.min(maxX1 + 1, minX2) - 1; x >= minX1; x--) {\n        // x in R1 left of R2\n        callback(x, y);\n      }\n      // Strictly right:\n      for (\n        x = Math.max(minX1, maxX2 + 1); // x in R1 right of R2\n        x <= maxX1;\n        x++\n      ) {\n        callback(x, y);\n      }\n    }\n  }\n\n  /**\n   * Removes marker from cell. O(N).\n   */\n  private _removeMarkerFromCell(\n    cell: google.maps.Marker[],\n    marker: google.maps.Marker\n  ): number {\n    let shift = 0;\n    for (let i = 0; i < cell.length; ++i) {\n      if (cell[i] === marker) {\n        cell.splice(i--, 1);\n        shift++;\n      }\n    }\n    return shift;\n  }\n}\n\nexport { MarkerManager };\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @ignore\n *\n * @param lng\n */\nfunction lngToX(lng: number): number {\n  return 1 + lng / 180;\n}\n/**\n * @ignore\n *\n * @param {number} lat\n * @returns {number}\n */\nfunction latToY(lat: number): number {\n  const sinofphi = Math.sin((lat * Math.PI) / 180);\n  return 1 - (0.5 / Math.PI) * Math.log((1 + sinofphi) / (1 - sinofphi));\n}\n\n/**\n * @ignore\n *\n * @param latlng\n * @param zoom\n */\nexport function latLngToPixel(\n  latlng: google.maps.LatLng,\n  zoom: number\n): google.maps.Point {\n  return new google.maps.Point(\n    ~~(0.5 + lngToX(latlng.lng()) * (2 << (zoom + 6))),\n    ~~(0.5 + latToY(latlng.lat()) * (2 << (zoom + 6)))\n  );\n}\n"],"names":["GridBounds","bounds","z","minX","Math","min","x","maxX","max","minY","y","maxY","gridBounds","this","point","MarkerManager","map","maxZoom","trackMarkers","shown","borderPadding","_map","_mapZoom","getZoom","_maxZoom","_trackMarkers","_swPadding","google","maps","Size","_nePadding","_gridWidth","_grid","_numMarkers","shownMarkers","event","addListenerOnce","_this","_initialize","mapTypes","sType","get","addListener","_onMapMoveEnd","bind","resetManager","_shownBounds","_getMapGridBounds","trigger","marker","setMap","mapWidth","zoom","ceil","_tileSize","_processAll","_removeOverlay","latlng","padding","pixelPoint","Point","lng","lat","sinofphi","sin","PI","log","latLngToPixel","floor","width","height","minZoom","mPoint","getPosition","set","a","b","c","_onMarkerMoved","gridPoint","_getTilePoint","_getGridCellCreate","push","vertical","horizontal","oldPoint","newPoint","changed","oldGrid","newGrid","cell","_getGridCellNoCreate","_removeMarkerFromCell","_isGridPointVisible","_addOverlay","_notifyListeners","grid","markers","_getOptmaxZoom","i","length","_addMarkerBatch","total","LatLng","Marker","position","undefined","swPadding","nePadding","bl","getSouthWest","tr","getNorthEast","sw","ne","gw","_getGridBounds","getBounds","window","setTimeout","_updateMarkers","refresh","show","newBounds","equals","_rectangleDiff","_removeCellMarkers","_addCellMarkers","callback","_processCellMarkers","bounds1","bounds2","_rectangleDiffCoords","minX1","minY1","maxX1","maxY1","minX2","minY2","maxX2","maxY2","shift","splice"],"mappings":"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"}