{"version":3,"file":"markermanager.esm.js","sources":["../src/utils.ts","../src/gridbounds.ts","../src/markermanager.ts"],"sourcesContent":["/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @ignore\n *\n * @param lng\n */\nfunction lngToX(lng: number): number {\n  return 1 + lng / 180;\n}\n/**\n * @ignore\n *\n * @param {number} lat\n * @returns {number}\n */\nfunction latToY(lat: number): number {\n  const sinofphi = Math.sin((lat * Math.PI) / 180);\n  return 1 - (0.5 / Math.PI) * Math.log((1 + sinofphi) / (1 - sinofphi));\n}\n\n/**\n * @ignore\n *\n * @param latlng\n * @param zoom\n */\nexport function latLngToPixel(\n  latlng: google.maps.LatLng,\n  zoom: number\n): google.maps.Point {\n  return new google.maps.Point(\n    ~~(0.5 + lngToX(latlng.lng()) * (2 << (zoom + 6))),\n    ~~(0.5 + latToY(latlng.lat()) * (2 << (zoom + 6)))\n  );\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Helper class to create a bounds of INT ranges.\n * @ignore\n */\nexport class GridBounds {\n  public z: number;\n  public minX: number;\n  public maxX: number;\n  public minY: number;\n  public maxY: number;\n\n  /**\n   *\n   * @param bounds\n   * @param z\n   */\n  constructor(bounds: google.maps.Point[], z: number) {\n    // [sw, ne]\n    this.z = z;\n    this.minX = Math.min(bounds[0].x, bounds[1].x);\n    this.maxX = Math.max(bounds[0].x, bounds[1].x);\n    this.minY = Math.min(bounds[0].y, bounds[1].y);\n    this.maxY = Math.max(bounds[0].y, bounds[1].y);\n  }\n\n  /**\n   * Returns true if this bounds equal the given bounds.\n   * @param {GridBounds} gridBounds GridBounds The bounds to test.\n   * @return {Boolean} This Bounds equals the given GridBounds.\n   */\n  equals(gridBounds: GridBounds): boolean {\n    if (\n      this.maxX === gridBounds.maxX &&\n      this.maxY === gridBounds.maxY &&\n      this.minX === gridBounds.minX &&\n      this.minY === gridBounds.minY\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Returns true if this bounds (inclusively) contains the given point.\n   * @param {Point} point  The point to test.\n   * @return {Boolean} This Bounds contains the given Point.\n   */\n  containsPoint(point: google.maps.Point): boolean {\n    return (\n      this.minX <= point.x &&\n      this.maxX >= point.x &&\n      this.minY <= point.y &&\n      this.maxY >= point.y\n    );\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/// <reference types=\"@types/googlemaps\" />\n\nimport { latLngToPixel } from \"./utils\";\nimport { GridBounds } from \"./gridbounds\";\n\ninterface Options {\n  maxZoom?: number;\n  shown?: boolean;\n  trackMarkers?: boolean;\n  borderPadding?: number;\n}\n\n/**\n * Creates a new MarkerManager that will show/hide markers on a map.\n */\nclass MarkerManager {\n  public shown: boolean;\n  public shownMarkers: number;\n\n  private _map: google.maps.Map;\n  private _mapZoom: number;\n  private _maxZoom: number;\n  private _tileSize = 1024;\n  private _trackMarkers: boolean;\n  private _swPadding: google.maps.Size;\n  private _nePadding: google.maps.Size;\n  private _gridWidth: { [k: string]: number };\n  private _grid: google.maps.Marker[][][][];\n  private _numMarkers: { [k: string]: number };\n  private _shownBounds: GridBounds;\n\n  /**\n   * @constructor\n   * @param map The map to manage.\n   * @param {Options} options\n   */\n  constructor(\n    map: google.maps.Map,\n    { maxZoom = 19, trackMarkers, shown = true, borderPadding = 100 }: Options\n  ) {\n    this._map = map;\n    this._mapZoom = map.getZoom();\n    this._maxZoom = maxZoom;\n    this._trackMarkers = trackMarkers;\n\n    // The padding in pixels beyond the viewport, where we will pre-load markers.\n    this._swPadding = new google.maps.Size(-borderPadding, borderPadding);\n    this._nePadding = new google.maps.Size(borderPadding, -borderPadding);\n\n    this._gridWidth = {};\n    this._grid = [];\n    this._grid[this._maxZoom] = [];\n    this._numMarkers = {};\n    this._numMarkers[this._maxZoom] = 0;\n\n    this.shownMarkers = 0;\n    this.shown = shown;\n\n    google.maps.event.addListenerOnce(map, \"idle\", () => {\n      this._initialize();\n    });\n  }\n\n  private _initialize(): void {\n    const mapTypes = this._map.mapTypes;\n\n    // Find max zoom level\n    let mapMaxZoom = 1;\n    for (const sType in mapTypes) {\n      if (\n        sType in mapTypes &&\n        mapTypes.get(sType) &&\n        mapTypes.get(sType).maxZoom === \"number\"\n      ) {\n        const mapTypeMaxZoom = this._map.mapTypes.get(sType).maxZoom;\n        if (mapTypeMaxZoom > mapMaxZoom) {\n          mapMaxZoom = mapTypeMaxZoom;\n        }\n      }\n    }\n\n    google.maps.event.addListener(\n      this._map,\n      \"dragend\",\n      this._onMapMoveEnd.bind(this)\n    );\n\n    google.maps.event.addListener(\n      this._map,\n      \"idle\",\n      this._onMapMoveEnd.bind(this)\n    );\n\n    google.maps.event.addListener(\n      this._map,\n      \"zoom_changed\",\n      this._onMapMoveEnd.bind(this)\n    );\n\n    this.resetManager();\n\n    this._shownBounds = this._getMapGridBounds();\n\n    google.maps.event.trigger(this, \"loaded\");\n  }\n  /**\n   * This closure provide easy access to the map.\n   * They are used as callbacks, not as methods.\n   * @param marker Marker to be removed from the map\n   */\n  private _removeOverlay(marker: google.maps.Marker): void {\n    marker.setMap(null);\n    this.shownMarkers--;\n  }\n\n  /**\n   * This closure provide easy access to the map.\n   * They are used as callbacks, not as methods.\n   * @param marker Marker to be added to the map\n   */\n  private _addOverlay(marker: google.maps.Marker): void {\n    if (this.shown) {\n      marker.setMap(this._map);\n      this.shownMarkers++;\n    }\n  }\n\n  /**\n   * Initializes MarkerManager arrays for all zoom levels\n   * Called by constructor and by clearAllMarkers\n   */\n  public resetManager(): void {\n    let mapWidth = 256;\n    for (let zoom = 0; zoom <= this._maxZoom; ++zoom) {\n      this._grid[zoom] = [];\n      this._numMarkers[zoom] = 0;\n      this._gridWidth[zoom] = Math.ceil(mapWidth / this._tileSize);\n      mapWidth <<= 1;\n    }\n  }\n\n  /**\n   * Removes all markers in the manager, and\n   * removes any visible markers from the map.\n   */\n  public clearMarkers(): void {\n    this._processAll(this._shownBounds, this._removeOverlay.bind(this));\n    this.resetManager();\n  }\n\n  /**\n   * Gets the tile coordinate for a given latlng point.\n   *\n   * @param {LatLng} latlng The geographical point.\n   * @param {Number} zoom The zoom level.\n   * @param {google.maps.Size} padding The padding used to shift the pixel coordinate.\n   *               Used for expanding a bounds to include an extra padding\n   *               of pixels surrounding the bounds.\n   * @return {GPoint} The point in tile coordinates.\n   *\n   */\n  private _getTilePoint(\n    latlng: google.maps.LatLng,\n    zoom: number,\n    padding: google.maps.Size\n  ): google.maps.Point {\n    const pixelPoint = latLngToPixel(latlng, zoom);\n\n    const point = new google.maps.Point(\n      Math.floor((pixelPoint.x + padding.width) / this._tileSize),\n      Math.floor((pixelPoint.y + padding.height) / this._tileSize)\n    );\n\n    return point;\n  }\n\n  /**\n   * Finds the appropriate place to add the marker to the grid.\n   * Optimized for speed; does not actually add the marker to the map.\n   * Designed for batch-_processing thousands of markers.\n   *\n   * @param {Marker} marker The marker to add.\n   * @param {Number} minZoom The minimum zoom for displaying the marker.\n   * @param {Number} maxZoom The maximum zoom for displaying the marker.\n   */\n  private _addMarkerBatch(\n    marker: google.maps.Marker,\n    minZoom: number,\n    maxZoom: number\n  ): void {\n    const mPoint = marker.getPosition();\n    marker.set(\"__minZoom\", minZoom);\n\n    // Tracking markers is expensive, so we do this only if the\n    // user explicitly requested it when creating marker manager.\n    if (this._trackMarkers) {\n      google.maps.event.addListener(marker, \"changed\", function(a, b, c) {\n        this._onMarkerMoved(a, b, c);\n      });\n    }\n\n    const gridPoint = this._getTilePoint(\n      mPoint,\n      maxZoom,\n      new google.maps.Size(0, 0)\n    );\n\n    for (let zoom = maxZoom; zoom >= minZoom; zoom--) {\n      const cell = this._getGridCellCreate(gridPoint.x, gridPoint.y, zoom);\n      cell.push(marker);\n\n      gridPoint.x = gridPoint.x >> 1;\n      gridPoint.y = gridPoint.y >> 1;\n    }\n  }\n\n  /**\n   * Returns whether or not the given point is visible in the shown bounds. This\n   * is a helper method that takes care of the corner case, when shownBounds have\n   * negative minX value.\n   *\n   * @param {Point} point a point on a grid.\n   * @return {Boolean} Whether or not the given point is visible in the currently\n   * shown bounds.\n   */\n  private _isGridPointVisible(point: google.maps.Point): boolean {\n    const vertical =\n      this._shownBounds.minY <= point.y && point.y <= this._shownBounds.maxY;\n    const minX = this._shownBounds.minX;\n    let horizontal = minX <= point.x && point.x <= this._shownBounds.maxX;\n    if (!horizontal && minX < 0) {\n      // Shifts the negative part of the rectangle. As point.x is always less\n      // than grid width, only test shifted minX .. 0 part of the shown bounds.\n      const width = this._gridWidth[this._shownBounds.z];\n      horizontal = minX + width <= point.x && point.x <= width - 1;\n    }\n    return vertical && horizontal;\n  }\n\n  /**\n   * Reacts to a notification from a marker that it has moved to a new location.\n   * It scans the grid all all zoom levels and moves the marker from the old grid\n   * location to a new grid location.\n   *\n   * @param {Marker} marker The marker that moved.\n   * @param {LatLng} oldPoint The old position of the marker.\n   * @param {LatLng} newPoint The new position of the marker.\n   */\n  private _onMarkerMoved(\n    marker: google.maps.Marker,\n    oldPoint: google.maps.LatLng,\n    newPoint: google.maps.LatLng\n  ): void {\n    // NOTE: We do not know the minimum or maximum zoom the marker was\n    // added at, so we start at the absolute maximum. Whenever we successfully\n    // remove a marker at a given zoom, we add it at the new grid coordinates.\n    let zoom = this._maxZoom;\n    let changed = false;\n    const oldGrid = this._getTilePoint(\n      oldPoint,\n      zoom,\n      new google.maps.Size(0, 0)\n    );\n    const newGrid = this._getTilePoint(\n      newPoint,\n      zoom,\n      new google.maps.Size(0, 0)\n    );\n    while (zoom >= 0 && (oldGrid.x !== newGrid.x || oldGrid.y !== newGrid.y)) {\n      const cell = this._getGridCellNoCreate(oldGrid.x, oldGrid.y, zoom);\n      if (cell) {\n        if (this._removeMarkerFromCell(cell, marker)) {\n          this._getGridCellCreate(newGrid.x, newGrid.y, zoom).push(marker);\n        }\n      }\n      // For the current zoom we also need to update the map. Markers that no\n      // longer are visible are removed from the map. Markers that moved into\n      // the shown bounds are added to the map. This also lets us keep the count\n      // of visible markers up to date.\n      if (zoom === this._mapZoom) {\n        if (this._isGridPointVisible(oldGrid)) {\n          if (!this._isGridPointVisible(newGrid)) {\n            this._removeOverlay(marker);\n            changed = true;\n          }\n        } else {\n          if (this._isGridPointVisible(newGrid)) {\n            this._addOverlay(marker);\n            changed = true;\n          }\n        }\n      }\n      oldGrid.x = oldGrid.x >> 1;\n      oldGrid.y = oldGrid.y >> 1;\n      newGrid.x = newGrid.x >> 1;\n      newGrid.y = newGrid.y >> 1;\n      --zoom;\n    }\n    if (changed) {\n      this._notifyListeners();\n    }\n  }\n\n  /**\n   * Removes marker from the manager and from the map\n   * (if it's currently visible).\n   * @param {GMarker} marker The marker to delete.\n   */\n  public removeMarker(marker: google.maps.Marker): void {\n    let zoom = this._maxZoom;\n    let changed = false;\n    const point = marker.getPosition();\n    const grid = this._getTilePoint(point, zoom, new google.maps.Size(0, 0));\n    while (zoom >= 0) {\n      const cell = this._getGridCellNoCreate(grid.x, grid.y, zoom);\n\n      if (cell) {\n        this._removeMarkerFromCell(cell, marker);\n      }\n      // For the current zoom we also need to update the map. Markers that no\n      // longer are visible are removed from the map. This also lets us keep the count\n      // of visible markers up to date.\n      if (zoom === this._mapZoom) {\n        if (this._isGridPointVisible(grid)) {\n          this._removeOverlay(marker);\n          changed = true;\n        }\n      }\n      grid.x = grid.x >> 1;\n      grid.y = grid.y >> 1;\n      --zoom;\n    }\n    if (changed) {\n      this._notifyListeners();\n    }\n    this._numMarkers[marker.get(\"__minZoom\")]--;\n  }\n\n  /**\n   * Add many markers at once.\n   * Does not actually update the map, just the internal grid.\n   *\n   * @param {Array of Marker} markers The markers to add.\n   * @param {Number} minZoom The minimum zoom level to display the markers.\n   * @param {Number} maxZoom The maximum zoom level to display the markers.\n   */\n  public addMarkers(\n    markers: google.maps.Marker[],\n    minZoom: number,\n    maxZoom: number\n  ): void {\n    maxZoom = this._getOptmaxZoom(maxZoom);\n    for (let i = markers.length - 1; i >= 0; i--) {\n      this._addMarkerBatch(markers[i], minZoom, maxZoom);\n    }\n\n    this._numMarkers[minZoom] += markers.length;\n  }\n\n  /**\n   * Returns the value of the optional maximum zoom. This method is defined so\n   * that we have just one place where optional maximum zoom is calculated.\n   *\n   * @param {Number} maxZoom The optinal maximum zoom.\n   * @return The maximum zoom.\n   */\n  private _getOptmaxZoom(maxZoom: number): number {\n    return maxZoom || this._maxZoom;\n  }\n\n  /**\n   * Calculates the total number of markers potentially visible at a given\n   * zoom level.\n   *\n   * @param {Number} zoom The zoom level to check.\n   */\n  public getMarkerCount(zoom: number): number {\n    let total = 0;\n    for (let z = 0; z <= zoom; z++) {\n      total += this._numMarkers[z];\n    }\n    return total;\n  }\n\n  /**\n   * Returns a marker given latitude, longitude and zoom. If the marker does not\n   * exist, the method will return a new marker. If a new marker is created,\n   * it will NOT be added to the manager.\n   *\n   * @param {Number} lat - the latitude of a marker.\n   * @param {Number} lng - the longitude of a marker.\n   * @param {Number} zoom - the zoom level\n   * @return {GMarker} marker - the marker found at lat and lng\n   */\n  public getMarker(lat: number, lng: number, zoom: number): google.maps.Marker {\n    const mPoint = new google.maps.LatLng(lat, lng);\n    const gridPoint = this._getTilePoint(\n      mPoint,\n      zoom,\n      new google.maps.Size(0, 0)\n    );\n\n    let marker = new google.maps.Marker({ position: mPoint });\n\n    const cell = this._getGridCellNoCreate(gridPoint.x, gridPoint.y, zoom);\n    if (cell !== undefined) {\n      for (let i = 0; i < cell.length; i++) {\n        if (\n          lat === cell[i].getPosition().lat() &&\n          lng === cell[i].getPosition().lng()\n        ) {\n          marker = cell[i];\n        }\n      }\n    }\n    return marker;\n  }\n\n  /**\n   * Add a single marker to the map.\n   *\n   * @param {Marker} marker The marker to add.\n   * @param {Number} minZoom The minimum zoom level to display the marker.\n   * @param {Number} maxZoom The maximum zoom level to display the marker.\n   */\n  public addMarker(\n    marker: google.maps.Marker,\n    minZoom: number,\n    maxZoom: number\n  ): void {\n    maxZoom = this._getOptmaxZoom(maxZoom);\n    this._addMarkerBatch(marker, minZoom, maxZoom);\n    const gridPoint = this._getTilePoint(\n      marker.getPosition(),\n      this._mapZoom,\n      new google.maps.Size(0, 0)\n    );\n    if (\n      this._isGridPointVisible(gridPoint) &&\n      minZoom <= this._shownBounds.z &&\n      this._shownBounds.z <= maxZoom\n    ) {\n      this._addOverlay(marker);\n      this._notifyListeners();\n    }\n    this._numMarkers[minZoom]++;\n  }\n\n  /**\n   * Get a cell in the grid, creating it first if necessary.\n   *\n   * Optimization candidate\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   * @return {Array} The cell in the array.\n   */\n  private _getGridCellCreate(\n    x: number,\n    y: number,\n    z: number\n  ): google.maps.Marker[] {\n    // TODO(jpoehnelt) document this\n    if (x < 0) {\n      x += this._gridWidth[z];\n    }\n\n    if (!this._grid[z]) {\n      this._grid[z] = [];\n    }\n    if (!this._grid[z][x]) {\n      this._grid[z][x] = [];\n    }\n    if (!this._grid[z][x][y]) {\n      this._grid[z][x][y] = [];\n    }\n    return this._grid[z][x][y];\n  }\n\n  /**\n   * Get a cell in the grid, returning undefined if it does not exist.\n   *\n   * NOTE: Optimized for speed -- otherwise could combine with _getGridCellCreate.\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   * @return {Array} The cell in the array.\n   */\n  private _getGridCellNoCreate(\n    x: number,\n    y: number,\n    z: number\n  ): google.maps.Marker[] | null {\n    if (x < 0) {\n      x += this._gridWidth[z];\n    }\n\n    if (!this._grid[z]) {\n      return null;\n    }\n    if (!this._grid[z][x]) {\n      return null;\n    }\n    if (!this._grid[z][x][y]) {\n      return null;\n    }\n    return this._grid[z][x][y];\n  }\n\n  /**\n   * Turns at geographical bounds into a grid-space bounds.\n   *\n   * @param {LatLngBounds} bounds The geographical bounds.\n   * @param {Number} zoom The zoom level of the bounds.\n   * @param {google.maps.Size} swPadding The padding in pixels to extend beyond the\n   * given bounds.\n   * @param {google.maps.Size} nePadding The padding in pixels to extend beyond the\n   * given bounds.\n   * @return {GridBounds} The bounds in grid space.\n   */\n  private _getGridBounds(\n    bounds: google.maps.LatLngBounds,\n    zoom: number,\n    swPadding: google.maps.Size,\n    nePadding: google.maps.Size\n  ): GridBounds {\n    zoom = Math.min(zoom, this._maxZoom);\n\n    const bl = bounds.getSouthWest();\n    const tr = bounds.getNorthEast();\n    const sw = this._getTilePoint(bl, zoom, swPadding);\n\n    const ne = this._getTilePoint(tr, zoom, nePadding);\n    const gw = this._gridWidth[zoom];\n\n    // Crossing the prime meridian requires correction of bounds.\n    if (tr.lng() < bl.lng() || ne.x < sw.x) {\n      sw.x -= gw;\n    }\n    if (ne.x - sw.x + 1 >= gw) {\n      // Computed grid bounds are larger than the world; truncate.\n      sw.x = 0;\n      ne.x = gw - 1;\n    }\n\n    const gridBounds = new GridBounds([sw, ne], zoom);\n    gridBounds.z = zoom;\n\n    return gridBounds;\n  }\n\n  /**\n   * Gets the grid-space bounds for the current map viewport.\n   *\n   * @return {Bounds} The bounds in grid space.\n   */\n  private _getMapGridBounds(): GridBounds {\n    return this._getGridBounds(\n      this._map.getBounds(),\n      this._mapZoom,\n      this._swPadding,\n      this._nePadding\n    );\n  }\n\n  /**\n   * Event listener for map:movend.\n   * NOTE: Use a timeout so that the user is not blocked\n   * from moving the map.\n   *\n   * Removed this because a a lack of a scopy override/callback function on events.\n   */\n  private _onMapMoveEnd(): void {\n    window.setTimeout(this._updateMarkers.bind(this), 0);\n  }\n\n  /**\n   * Is this layer visible?\n   *\n   * Returns visibility setting\n   *\n   * @return {Boolean} Visible\n   */\n  public visible(): boolean {\n    return this.shown ? true : false;\n  }\n\n  /**\n   * Returns true if the manager is hidden.\n   * Otherwise returns false.\n   * @return {Boolean} Hidden\n   */\n  public isHidden(): boolean {\n    return !this.shown;\n  }\n\n  /**\n   * Shows the manager if it's currently hidden.\n   */\n  public show(): void {\n    this.shown = true;\n    this.refresh();\n  }\n\n  /**\n   * Hides the manager if it's currently visible\n   */\n  public hide(): void {\n    this.shown = false;\n    this.refresh();\n  }\n\n  /**\n   * Toggles the visibility of the manager.\n   */\n  public toggle(): void {\n    this.shown = !this.shown;\n    this.refresh();\n  }\n\n  /**\n   * Refresh forces the marker-manager into a good state.\n   * <ol>\n   *   <li>If never before initialized, shows all the markers.</li>\n   *   <li>If previously initialized, removes and re-adds all markers.</li>\n   * </ol>\n   */\n  public refresh(): void {\n    if (this.shownMarkers > 0) {\n      this._processAll(this._shownBounds, this._removeOverlay.bind(this));\n    }\n    // An extra check on this.show to increase performance (no need to _processAll_)\n    if (this.show) {\n      this._processAll(this._shownBounds, this._addOverlay.bind(this));\n    }\n    this._notifyListeners();\n  }\n\n  /**\n   * After the viewport may have changed, add or remove markers as needed.\n   */\n  private _updateMarkers(): void {\n    this._mapZoom = this._map.getZoom();\n    const newBounds = this._getMapGridBounds();\n\n    // If the move does not include new grid sections,\n    // we have no work to do:\n    if (\n      newBounds.equals(this._shownBounds) &&\n      newBounds.z === this._shownBounds.z\n    ) {\n      return;\n    }\n\n    if (newBounds.z !== this._shownBounds.z) {\n      this._processAll(this._shownBounds, this._removeOverlay.bind(this));\n      if (this.show) {\n        // performance\n        this._processAll(newBounds, this._addOverlay.bind(this));\n      }\n    } else {\n      // Remove markers:\n      this._rectangleDiff(\n        this._shownBounds,\n        newBounds,\n        this._removeCellMarkers.bind(this)\n      );\n\n      // Add markers:\n      if (this.show) {\n        // performance\n        this._rectangleDiff(\n          newBounds,\n          this._shownBounds,\n          this._addCellMarkers.bind(this)\n        );\n      }\n    }\n    this._shownBounds = newBounds;\n\n    this._notifyListeners();\n  }\n\n  /**\n   * Notify listeners when the state of what is displayed changes.\n   */\n  private _notifyListeners(): void {\n    google.maps.event.trigger(\n      this,\n      \"changed\",\n      this._shownBounds,\n      this.shownMarkers\n    );\n  }\n\n  /**\n   * Process all markers in the bounds provided, using a callback.\n   *\n   * @param {Bounds} bounds The bounds in grid space.\n   * @param {Function} callback The function to call for each marker.\n   */\n  private _processAll(\n    bounds: GridBounds,\n    callback: (marker: google.maps.Marker) => void\n  ): void {\n    for (let x = bounds.minX; x <= bounds.maxX; x++) {\n      for (let y = bounds.minY; y <= bounds.maxY; y++) {\n        this._processCellMarkers(x, y, bounds.z, callback);\n      }\n    }\n  }\n\n  /**\n   * Process all markers in the grid cell, using a callback.\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   * @param {Function} callback The function to call for each marker.\n   */\n  private _processCellMarkers(\n    x: number,\n    y: number,\n    z: number,\n    callback: (marker: google.maps.Marker) => void\n  ): void {\n    const cell = this._getGridCellNoCreate(x, y, z);\n    if (cell) {\n      for (let i = cell.length - 1; i >= 0; i--) {\n        callback(cell[i]);\n      }\n    }\n  }\n\n  /**\n   * Remove all markers in a grid cell.\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   */\n  private _removeCellMarkers(x: number, y: number, z: number): void {\n    this._processCellMarkers(x, y, z, this._removeOverlay.bind(this));\n  }\n\n  /**\n   * Add all markers in a grid cell.\n   *\n   * @param {Number} x The x coordinate of the cell.\n   * @param {Number} y The y coordinate of the cell.\n   * @param {Number} z The z coordinate of the cell.\n   */\n  private _addCellMarkers(x: number, y: number, z: number): void {\n    this._processCellMarkers(x, y, z, this._addOverlay.bind(this));\n  }\n\n  /**\n   * Use the _rectangleDiffCoords function to process all grid cells\n   * that are in bounds1 but not bounds2, using a callback, and using\n   * the current MarkerManager object as the instance.\n   *\n   * Pass the z parameter to the callback in addition to x and y.\n   *\n   * @param {Bounds} bounds1 The bounds of all points we may _process.\n   * @param {Bounds} bounds2 The bounds of points to exclude.\n   * @param {Function} callback The callback function to call\n   *                   for each grid coordinate (x, y, z).\n   */\n  private _rectangleDiff(\n    bounds1: GridBounds,\n    bounds2: GridBounds,\n    callback: (x: number, y: number, z: number) => void\n  ): void {\n    this._rectangleDiffCoords(bounds1, bounds2, function(x, y) {\n      callback(x, y, bounds1.z);\n    });\n  }\n\n  /**\n   * Calls the function for all points in bounds1, not in bounds2\n   *\n   * @param {Bounds} bounds1 The bounds of all points we may process.\n   * @param {Bounds} bounds2 The bounds of points to exclude.\n   * @param {Function} callback The callback function to call\n   *                   for each grid coordinate.\n   */\n  private _rectangleDiffCoords(\n    bounds1: GridBounds,\n    bounds2: GridBounds,\n    callback: (x: number, y: number) => void\n  ): void {\n    const minX1 = bounds1.minX;\n    const minY1 = bounds1.minY;\n    const maxX1 = bounds1.maxX;\n    const maxY1 = bounds1.maxY;\n    const minX2 = bounds2.minX;\n    const minY2 = bounds2.minY;\n    const maxX2 = bounds2.maxX;\n    const maxY2 = bounds2.maxY;\n\n    let x, y;\n    for (x = minX1; x <= maxX1; x++) {\n      // All x in R1\n      // All above:\n      for (y = minY1; y <= maxY1 && y < minY2; y++) {\n        // y in R1 above R2\n        callback(x, y);\n      }\n      // All below:\n      for (\n        y = Math.max(maxY2 + 1, minY1); // y in R1 below R2\n        y <= maxY1;\n        y++\n      ) {\n        callback(x, y);\n      }\n    }\n\n    for (y = Math.max(minY1, minY2); y <= Math.min(maxY1, maxY2); y++) {\n      // All y in R2 and in R1\n      // Strictly left:\n      for (x = Math.min(maxX1 + 1, minX2) - 1; x >= minX1; x--) {\n        // x in R1 left of R2\n        callback(x, y);\n      }\n      // Strictly right:\n      for (\n        x = Math.max(minX1, maxX2 + 1); // x in R1 right of R2\n        x <= maxX1;\n        x++\n      ) {\n        callback(x, y);\n      }\n    }\n  }\n\n  /**\n   * Removes marker from cell. O(N).\n   */\n  private _removeMarkerFromCell(\n    cell: google.maps.Marker[],\n    marker: google.maps.Marker\n  ): number {\n    let shift = 0;\n    for (let i = 0; i < cell.length; ++i) {\n      if (cell[i] === marker) {\n        cell.splice(i--, 1);\n        shift++;\n      }\n    }\n    return shift;\n  }\n}\n\nexport { MarkerManager };\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAqBA,SAAS,MAAM,CAAC,GAAW;IACzB,OAAO,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC;CACtB;;;;;;;AAOD,SAAS,MAAM,CAAC,GAAW;IACzB,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,EAAE,IAAI,GAAG,CAAC,CAAC;IACjD,OAAO,CAAC,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC,EAAE,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,QAAQ,KAAK,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC;CACxE;;;;;;;AAQD,SAAgB,aAAa,CAC3B,MAA0B,EAC1B,IAAY;IAEZ,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,CAC1B,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,EAClD,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CACnD,CAAC;CACH;;ACjDD;;;;;;;;;;;;;;;;;;;AAoBA,MAAa,UAAU;;;;;;IAYrB,YAAY,MAA2B,EAAE,CAAS;;QAEhD,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACX,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KAChD;;;;;;IAOD,MAAM,CAAC,UAAsB;QAC3B,IACE,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,IAAI;YAC7B,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,IAAI;YAC7B,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,IAAI;YAC7B,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,IAAI,EAC7B;YACA,OAAO,IAAI,CAAC;SACb;aAAM;YACL,OAAO,KAAK,CAAC;SACd;KACF;;;;;;IAOD,aAAa,CAAC,KAAwB;QACpC,QACE,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,CAAC;YACpB,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,CAAC;YACpB,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,CAAC;YACpB,IAAI,CAAC,IAAI,IAAI,KAAK,CAAC,CAAC,EACpB;KACH;CACF;;ACxED;;;;;;;;;;;;;;;AAgBA,AAYA;;;AAGA,MAAM,aAAa;;;;;;IAqBjB,YACE,GAAoB,EACpB,EAAE,OAAO,GAAG,EAAE,EAAE,YAAY,EAAE,KAAK,GAAG,IAAI,EAAE,aAAa,GAAG,GAAG,EAAW;QAhBpE,cAAS,GAAG,IAAI,CAAC;QAkBvB,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;QAChB,IAAI,CAAC,QAAQ,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;QAC9B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC;;QAGlC,IAAI,CAAC,UAAU,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;QACtE,IAAI,CAAC,UAAU,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,aAAa,CAAC,CAAC;QAEtE,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;QACrB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;QAChB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;QACtB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAEpC,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;QACtB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QAEnB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,GAAG,EAAE,MAAM,EAAE;YAC7C,IAAI,CAAC,WAAW,EAAE,CAAC;SACpB,CAAC,CAAC;KACJ;IAEO,WAAW;QACjB,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;QAIpC,KAAK,MAAM,KAAK,IAAI,QAAQ,EAAE;YAC5B,IACE,KAAK,IAAI,QAAQ;gBACjB,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC;gBACnB,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,OAAO,KAAK,QAAQ,EACxC;gBACA,MAAM,cAAc,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC;aAI9D;SACF;QAED,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAC3B,IAAI,CAAC,IAAI,EACT,SAAS,EACT,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAC9B,CAAC;QAEF,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAC3B,IAAI,CAAC,IAAI,EACT,MAAM,EACN,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAC9B,CAAC;QAEF,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAC3B,IAAI,CAAC,IAAI,EACT,cAAc,EACd,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAC9B,CAAC;QAEF,IAAI,CAAC,YAAY,EAAE,CAAC;QAEpB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAE7C,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;KAC3C;;;;;;IAMO,cAAc,CAAC,MAA0B;QAC/C,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACpB,IAAI,CAAC,YAAY,EAAE,CAAC;KACrB;;;;;;IAOO,WAAW,CAAC,MAA0B;QAC5C,IAAI,IAAI,CAAC,KAAK,EAAE;YACd,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACzB,IAAI,CAAC,YAAY,EAAE,CAAC;SACrB;KACF;;;;;IAMM,YAAY;QACjB,IAAI,QAAQ,GAAG,GAAG,CAAC;QACnB,KAAK,IAAI,IAAI,GAAG,CAAC,EAAE,IAAI,IAAI,IAAI,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE;YAChD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;YACtB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAC3B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC;YAC7D,QAAQ,KAAK,CAAC,CAAC;SAChB;KACF;;;;;IAMM,YAAY;QACjB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACpE,IAAI,CAAC,YAAY,EAAE,CAAC;KACrB;;;;;;;;;;;;IAaO,aAAa,CACnB,MAA0B,EAC1B,IAAY,EACZ,OAAyB;QAEzB,MAAM,UAAU,GAAG,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAE/C,MAAM,KAAK,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,CACjC,IAAI,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC,CAAC,GAAG,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,SAAS,CAAC,EAC3D,IAAI,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC,CAAC,GAAG,OAAO,CAAC,MAAM,IAAI,IAAI,CAAC,SAAS,CAAC,CAC7D,CAAC;QAEF,OAAO,KAAK,CAAC;KACd;;;;;;;;;;IAWO,eAAe,CACrB,MAA0B,EAC1B,OAAe,EACf,OAAe;QAEf,MAAM,MAAM,GAAG,MAAM,CAAC,WAAW,EAAE,CAAC;QACpC,MAAM,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;;;QAIjC,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,MAAM,EAAE,SAAS,EAAE,UAAS,CAAC,EAAE,CAAC,EAAE,CAAC;gBAC/D,IAAI,CAAC,cAAc,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;aAC9B,CAAC,CAAC;SACJ;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,aAAa,CAClC,MAAM,EACN,OAAO,EACP,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAC3B,CAAC;QAEF,KAAK,IAAI,IAAI,GAAG,OAAO,EAAE,IAAI,IAAI,OAAO,EAAE,IAAI,EAAE,EAAE;YAChD,MAAM,IAAI,GAAG,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YACrE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAElB,SAAS,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC;YAC/B,SAAS,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC;SAChC;KACF;;;;;;;;;;IAWO,mBAAmB,CAAC,KAAwB;QAClD,MAAM,QAAQ,GACZ,IAAI,CAAC,YAAY,CAAC,IAAI,IAAI,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;QACzE,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;QACpC,IAAI,UAAU,GAAG,IAAI,IAAI,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;QACtE,IAAI,CAAC,UAAU,IAAI,IAAI,GAAG,CAAC,EAAE;;;YAG3B,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;YACnD,UAAU,GAAG,IAAI,GAAG,KAAK,IAAI,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC;SAC9D;QACD,OAAO,QAAQ,IAAI,UAAU,CAAC;KAC/B;;;;;;;;;;IAWO,cAAc,CACpB,MAA0B,EAC1B,QAA4B,EAC5B,QAA4B;;;;QAK5B,IAAI,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC;QACzB,IAAI,OAAO,GAAG,KAAK,CAAC;QACpB,MAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAChC,QAAQ,EACR,IAAI,EACJ,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAC3B,CAAC;QACF,MAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAChC,QAAQ,EACR,IAAI,EACJ,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAC3B,CAAC;QACF,OAAO,IAAI,IAAI,CAAC,KAAK,OAAO,CAAC,CAAC,KAAK,OAAO,CAAC,CAAC,IAAI,OAAO,CAAC,CAAC,KAAK,OAAO,CAAC,CAAC,CAAC,EAAE;YACxE,MAAM,IAAI,GAAG,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YACnE,IAAI,IAAI,EAAE;gBACR,IAAI,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE;oBAC5C,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;iBAClE;aACF;;;;;YAKD,IAAI,IAAI,KAAK,IAAI,CAAC,QAAQ,EAAE;gBAC1B,IAAI,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,EAAE;oBACrC,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,EAAE;wBACtC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;wBAC5B,OAAO,GAAG,IAAI,CAAC;qBAChB;iBACF;qBAAM;oBACL,IAAI,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,EAAE;wBACrC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;wBACzB,OAAO,GAAG,IAAI,CAAC;qBAChB;iBACF;aACF;YACD,OAAO,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC;YAC3B,OAAO,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC;YAC3B,OAAO,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC;YAC3B,OAAO,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC;YAC3B,EAAE,IAAI,CAAC;SACR;QACD,IAAI,OAAO,EAAE;YACX,IAAI,CAAC,gBAAgB,EAAE,CAAC;SACzB;KACF;;;;;;IAOM,YAAY,CAAC,MAA0B;QAC5C,IAAI,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC;QACzB,IAAI,OAAO,GAAG,KAAK,CAAC;QACpB,MAAM,KAAK,GAAG,MAAM,CAAC,WAAW,EAAE,CAAC;QACnC,MAAM,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACzE,OAAO,IAAI,IAAI,CAAC,EAAE;YAChB,MAAM,IAAI,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YAE7D,IAAI,IAAI,EAAE;gBACR,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;aAC1C;;;;YAID,IAAI,IAAI,KAAK,IAAI,CAAC,QAAQ,EAAE;gBAC1B,IAAI,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,EAAE;oBAClC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;oBAC5B,OAAO,GAAG,IAAI,CAAC;iBAChB;aACF;YACD,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;YACrB,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;YACrB,EAAE,IAAI,CAAC;SACR;QACD,IAAI,OAAO,EAAE;YACX,IAAI,CAAC,gBAAgB,EAAE,CAAC;SACzB;QACD,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC;KAC7C;;;;;;;;;IAUM,UAAU,CACf,OAA6B,EAC7B,OAAe,EACf,OAAe;QAEf,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QACvC,KAAK,IAAI,CAAC,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YAC5C,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;SACpD;QAED,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC;KAC7C;;;;;;;;IASO,cAAc,CAAC,OAAe;QACpC,OAAO,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC;KACjC;;;;;;;IAQM,cAAc,CAAC,IAAY;QAChC,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,EAAE;YAC9B,KAAK,IAAI,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;SAC9B;QACD,OAAO,KAAK,CAAC;KACd;;;;;;;;;;;IAYM,SAAS,CAAC,GAAW,EAAE,GAAW,EAAE,IAAY;QACrD,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QAChD,MAAM,SAAS,GAAG,IAAI,CAAC,aAAa,CAClC,MAAM,EACN,IAAI,EACJ,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAC3B,CAAC;QAEF,IAAI,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;QAE1D,MAAM,IAAI,GAAG,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;QACvE,IAAI,IAAI,KAAK,SAAS,EAAE;YACtB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACpC,IACE,GAAG,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,GAAG,EAAE;oBACnC,GAAG,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,GAAG,EAAE,EACnC;oBACA,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;iBAClB;aACF;SACF;QACD,OAAO,MAAM,CAAC;KACf;;;;;;;;IASM,SAAS,CACd,MAA0B,EAC1B,OAAe,EACf,OAAe;QAEf,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QACvC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;QAC/C,MAAM,SAAS,GAAG,IAAI,CAAC,aAAa,CAClC,MAAM,CAAC,WAAW,EAAE,EACpB,IAAI,CAAC,QAAQ,EACb,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAC3B,CAAC;QACF,IACE,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC;YACnC,OAAO,IAAI,IAAI,CAAC,YAAY,CAAC,CAAC;YAC9B,IAAI,CAAC,YAAY,CAAC,CAAC,IAAI,OAAO,EAC9B;YACA,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YACzB,IAAI,CAAC,gBAAgB,EAAE,CAAC;SACzB;QACD,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,EAAE,CAAC;KAC7B;;;;;;;;;;;IAYO,kBAAkB,CACxB,CAAS,EACT,CAAS,EACT,CAAS;;QAGT,IAAI,CAAC,GAAG,CAAC,EAAE;YACT,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;SACzB;QAED,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;YAClB,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC;SACpB;QACD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;YACrB,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC;SACvB;QACD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;YACxB,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC;SAC1B;QACD,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KAC5B;;;;;;;;;;;IAYO,oBAAoB,CAC1B,CAAS,EACT,CAAS,EACT,CAAS;QAET,IAAI,CAAC,GAAG,CAAC,EAAE;YACT,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;SACzB;QAED,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;YAClB,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;YACrB,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;YACxB,OAAO,IAAI,CAAC;SACb;QACD,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KAC5B;;;;;;;;;;;;IAaO,cAAc,CACpB,MAAgC,EAChC,IAAY,EACZ,SAA2B,EAC3B,SAA2B;QAE3B,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAErC,MAAM,EAAE,GAAG,MAAM,CAAC,YAAY,EAAE,CAAC;QACjC,MAAM,EAAE,GAAG,MAAM,CAAC,YAAY,EAAE,CAAC;QACjC,MAAM,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,EAAE,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;QAEnD,MAAM,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,EAAE,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;QACnD,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;;QAGjC,IAAI,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE;YACtC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;SACZ;QACD,IAAI,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE;;YAEzB,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;YACT,EAAE,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;SACf;QAED,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;QAClD,UAAU,CAAC,CAAC,GAAG,IAAI,CAAC;QAEpB,OAAO,UAAU,CAAC;KACnB;;;;;;IAOO,iBAAiB;QACvB,OAAO,IAAI,CAAC,cAAc,CACxB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,EACrB,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,UAAU,CAChB,CAAC;KACH;;;;;;;;IASO,aAAa;QACnB,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;KACtD;;;;;;;;IASM,OAAO;QACZ,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,GAAG,KAAK,CAAC;KAClC;;;;;;IAOM,QAAQ;QACb,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC;KACpB;;;;IAKM,IAAI;QACT,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,OAAO,EAAE,CAAC;KAChB;;;;IAKM,IAAI;QACT,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,OAAO,EAAE,CAAC;KAChB;;;;IAKM,MAAM;QACX,IAAI,CAAC,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC;QACzB,IAAI,CAAC,OAAO,EAAE,CAAC;KAChB;;;;;;;;IASM,OAAO;QACZ,IAAI,IAAI,CAAC,YAAY,GAAG,CAAC,EAAE;YACzB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;SACrE;;QAED,IAAI,IAAI,CAAC,IAAI,EAAE;YACb,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;SAClE;QACD,IAAI,CAAC,gBAAgB,EAAE,CAAC;KACzB;;;;IAKO,cAAc;QACpB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;QACpC,MAAM,SAAS,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;;;QAI3C,IACE,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC;YACnC,SAAS,CAAC,CAAC,KAAK,IAAI,CAAC,YAAY,CAAC,CAAC,EACnC;YACA,OAAO;SACR;QAED,IAAI,SAAS,CAAC,CAAC,KAAK,IAAI,CAAC,YAAY,CAAC,CAAC,EAAE;YACvC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACpE,IAAI,IAAI,CAAC,IAAI,EAAE;;gBAEb,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;aAC1D;SACF;aAAM;;YAEL,IAAI,CAAC,cAAc,CACjB,IAAI,CAAC,YAAY,EACjB,SAAS,EACT,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CACnC,CAAC;;YAGF,IAAI,IAAI,CAAC,IAAI,EAAE;;gBAEb,IAAI,CAAC,cAAc,CACjB,SAAS,EACT,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAChC,CAAC;aACH;SACF;QACD,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;QAE9B,IAAI,CAAC,gBAAgB,EAAE,CAAC;KACzB;;;;IAKO,gBAAgB;QACtB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CACvB,IAAI,EACJ,SAAS,EACT,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,YAAY,CAClB,CAAC;KACH;;;;;;;IAQO,WAAW,CACjB,MAAkB,EAClB,QAA8C;QAE9C,KAAK,IAAI,CAAC,GAAG,MAAM,CAAC,IAAI,EAAE,CAAC,IAAI,MAAM,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE;YAC/C,KAAK,IAAI,CAAC,GAAG,MAAM,CAAC,IAAI,EAAE,CAAC,IAAI,MAAM,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE;gBAC/C,IAAI,CAAC,mBAAmB,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;aACpD;SACF;KACF;;;;;;;;;IAUO,mBAAmB,CACzB,CAAS,EACT,CAAS,EACT,CAAS,EACT,QAA8C;QAE9C,MAAM,IAAI,GAAG,IAAI,CAAC,oBAAoB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAChD,IAAI,IAAI,EAAE;YACR,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;gBACzC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;aACnB;SACF;KACF;;;;;;;;IASO,kBAAkB,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS;QACxD,IAAI,CAAC,mBAAmB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;KACnE;;;;;;;;IASO,eAAe,CAAC,CAAS,EAAE,CAAS,EAAE,CAAS;QACrD,IAAI,CAAC,mBAAmB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;KAChE;;;;;;;;;;;;;IAcO,cAAc,CACpB,OAAmB,EACnB,OAAmB,EACnB,QAAmD;QAEnD,IAAI,CAAC,oBAAoB,CAAC,OAAO,EAAE,OAAO,EAAE,UAAS,CAAC,EAAE,CAAC;YACvD,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;SAC3B,CAAC,CAAC;KACJ;;;;;;;;;IAUO,oBAAoB,CAC1B,OAAmB,EACnB,OAAmB,EACnB,QAAwC;QAExC,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;QAC3B,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;QAC3B,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;QAC3B,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;QAC3B,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;QAC3B,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;QAC3B,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;QAC3B,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC;QAE3B,IAAI,CAAC,EAAE,CAAC,CAAC;QACT,KAAK,CAAC,GAAG,KAAK,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,EAAE,EAAE;;;YAG/B,KAAK,CAAC,GAAG,KAAK,EAAE,CAAC,IAAI,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;;gBAE5C,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;aAChB;;YAED,KACE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,EAAE,KAAK,CAAC;aAC9B,CAAC,IAAI,KAAK,EACV,CAAC,EAAE,EACH;gBACA,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;aAChB;SACF;QAED,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE;;;YAGjE,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,EAAE,EAAE;;gBAExD,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;aAChB;;YAED,KACE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,GAAG,CAAC,CAAC;aAC9B,CAAC,IAAI,KAAK,EACV,CAAC,EAAE,EACH;gBACA,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;aAChB;SACF;KACF;;;;IAKO,qBAAqB,CAC3B,IAA0B,EAC1B,MAA0B;QAE1B,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YACpC,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;gBACtB,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;gBACpB,KAAK,EAAE,CAAC;aACT;SACF;QACD,OAAO,KAAK,CAAC;KACd;CACF;;;;"}