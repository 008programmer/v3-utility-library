{"code":"/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/// <reference types=\"@types/googlemaps\" />\r\nimport { latLngToPixel } from \"./utils\";\r\nimport { GridBounds } from \"./gridbounds\";\r\n/**\r\n * Creates a new MarkerManager that will show/hide markers on a map.\r\n */\r\nclass MarkerManager {\r\n    /**\r\n     * @constructor\r\n     * @param map The map to manage.\r\n     * @param {Options} options\r\n     */\r\n    constructor(map, { maxZoom = 19, trackMarkers, shown = true, borderPadding = 100 }) {\r\n        this._tileSize = 1024;\r\n        this._map = map;\r\n        this._mapZoom = map.getZoom();\r\n        this._maxZoom = maxZoom;\r\n        this._trackMarkers = trackMarkers;\r\n        // The padding in pixels beyond the viewport, where we will pre-load markers.\r\n        this._swPadding = new google.maps.Size(-borderPadding, borderPadding);\r\n        this._nePadding = new google.maps.Size(borderPadding, -borderPadding);\r\n        this._gridWidth = {};\r\n        this._grid = [];\r\n        this._grid[this._maxZoom] = [];\r\n        this._numMarkers = {};\r\n        this._numMarkers[this._maxZoom] = 0;\r\n        this.shownMarkers = 0;\r\n        this.shown = shown;\r\n        google.maps.event.addListenerOnce(map, \"idle\", () => {\r\n            this._initialize();\r\n        });\r\n    }\r\n    _initialize() {\r\n        const mapTypes = this._map.mapTypes;\r\n        // Find max zoom level\r\n        let mapMaxZoom = 1;\r\n        for (const sType in mapTypes) {\r\n            if (sType in mapTypes &&\r\n                mapTypes.get(sType) &&\r\n                mapTypes.get(sType).maxZoom === \"number\") {\r\n                const mapTypeMaxZoom = this._map.mapTypes.get(sType).maxZoom;\r\n                if (mapTypeMaxZoom > mapMaxZoom) {\r\n                    mapMaxZoom = mapTypeMaxZoom;\r\n                }\r\n            }\r\n        }\r\n        google.maps.event.addListener(this._map, \"dragend\", this._onMapMoveEnd.bind(this));\r\n        google.maps.event.addListener(this._map, \"idle\", this._onMapMoveEnd.bind(this));\r\n        google.maps.event.addListener(this._map, \"zoom_changed\", this._onMapMoveEnd.bind(this));\r\n        this.resetManager();\r\n        this._shownBounds = this._getMapGridBounds();\r\n        google.maps.event.trigger(this, \"loaded\");\r\n    }\r\n    /**\r\n     * This closure provide easy access to the map.\r\n     * They are used as callbacks, not as methods.\r\n     * @param marker Marker to be removed from the map\r\n     */\r\n    _removeOverlay(marker) {\r\n        marker.setMap(null);\r\n        this.shownMarkers--;\r\n    }\r\n    /**\r\n     * This closure provide easy access to the map.\r\n     * They are used as callbacks, not as methods.\r\n     * @param marker Marker to be added to the map\r\n     */\r\n    _addOverlay(marker) {\r\n        if (this.shown) {\r\n            marker.setMap(this._map);\r\n            this.shownMarkers++;\r\n        }\r\n    }\r\n    /**\r\n     * Initializes MarkerManager arrays for all zoom levels\r\n     * Called by constructor and by clearAllMarkers\r\n     */\r\n    resetManager() {\r\n        let mapWidth = 256;\r\n        for (let zoom = 0; zoom <= this._maxZoom; ++zoom) {\r\n            this._grid[zoom] = [];\r\n            this._numMarkers[zoom] = 0;\r\n            this._gridWidth[zoom] = Math.ceil(mapWidth / this._tileSize);\r\n            mapWidth <<= 1;\r\n        }\r\n    }\r\n    /**\r\n     * Removes all markers in the manager, and\r\n     * removes any visible markers from the map.\r\n     */\r\n    clearMarkers() {\r\n        this._processAll(this._shownBounds, this._removeOverlay.bind(this));\r\n        this.resetManager();\r\n    }\r\n    /**\r\n     * Gets the tile coordinate for a given latlng point.\r\n     *\r\n     * @param {LatLng} latlng The geographical point.\r\n     * @param {Number} zoom The zoom level.\r\n     * @param {google.maps.Size} padding The padding used to shift the pixel coordinate.\r\n     *               Used for expanding a bounds to include an extra padding\r\n     *               of pixels surrounding the bounds.\r\n     * @return {GPoint} The point in tile coordinates.\r\n     *\r\n     */\r\n    _getTilePoint(latlng, zoom, padding) {\r\n        const pixelPoint = latLngToPixel(latlng, zoom);\r\n        const point = new google.maps.Point(Math.floor((pixelPoint.x + padding.width) / this._tileSize), Math.floor((pixelPoint.y + padding.height) / this._tileSize));\r\n        return point;\r\n    }\r\n    /**\r\n     * Finds the appropriate place to add the marker to the grid.\r\n     * Optimized for speed; does not actually add the marker to the map.\r\n     * Designed for batch-_processing thousands of markers.\r\n     *\r\n     * @param {Marker} marker The marker to add.\r\n     * @param {Number} minZoom The minimum zoom for displaying the marker.\r\n     * @param {Number} maxZoom The maximum zoom for displaying the marker.\r\n     */\r\n    _addMarkerBatch(marker, minZoom, maxZoom) {\r\n        const mPoint = marker.getPosition();\r\n        marker.set(\"__minZoom\", minZoom);\r\n        // Tracking markers is expensive, so we do this only if the\r\n        // user explicitly requested it when creating marker manager.\r\n        if (this._trackMarkers) {\r\n            google.maps.event.addListener(marker, \"changed\", function (a, b, c) {\r\n                this._onMarkerMoved(a, b, c);\r\n            });\r\n        }\r\n        const gridPoint = this._getTilePoint(mPoint, maxZoom, new google.maps.Size(0, 0));\r\n        for (let zoom = maxZoom; zoom >= minZoom; zoom--) {\r\n            const cell = this._getGridCellCreate(gridPoint.x, gridPoint.y, zoom);\r\n            cell.push(marker);\r\n            gridPoint.x = gridPoint.x >> 1;\r\n            gridPoint.y = gridPoint.y >> 1;\r\n        }\r\n    }\r\n    /**\r\n     * Returns whether or not the given point is visible in the shown bounds. This\r\n     * is a helper method that takes care of the corner case, when shownBounds have\r\n     * negative minX value.\r\n     *\r\n     * @param {Point} point a point on a grid.\r\n     * @return {Boolean} Whether or not the given point is visible in the currently\r\n     * shown bounds.\r\n     */\r\n    _isGridPointVisible(point) {\r\n        const vertical = this._shownBounds.minY <= point.y && point.y <= this._shownBounds.maxY;\r\n        const minX = this._shownBounds.minX;\r\n        let horizontal = minX <= point.x && point.x <= this._shownBounds.maxX;\r\n        if (!horizontal && minX < 0) {\r\n            // Shifts the negative part of the rectangle. As point.x is always less\r\n            // than grid width, only test shifted minX .. 0 part of the shown bounds.\r\n            const width = this._gridWidth[this._shownBounds.z];\r\n            horizontal = minX + width <= point.x && point.x <= width - 1;\r\n        }\r\n        return vertical && horizontal;\r\n    }\r\n    /**\r\n     * Reacts to a notification from a marker that it has moved to a new location.\r\n     * It scans the grid all all zoom levels and moves the marker from the old grid\r\n     * location to a new grid location.\r\n     *\r\n     * @param {Marker} marker The marker that moved.\r\n     * @param {LatLng} oldPoint The old position of the marker.\r\n     * @param {LatLng} newPoint The new position of the marker.\r\n     */\r\n    _onMarkerMoved(marker, oldPoint, newPoint) {\r\n        // NOTE: We do not know the minimum or maximum zoom the marker was\r\n        // added at, so we start at the absolute maximum. Whenever we successfully\r\n        // remove a marker at a given zoom, we add it at the new grid coordinates.\r\n        let zoom = this._maxZoom;\r\n        let changed = false;\r\n        const oldGrid = this._getTilePoint(oldPoint, zoom, new google.maps.Size(0, 0));\r\n        const newGrid = this._getTilePoint(newPoint, zoom, new google.maps.Size(0, 0));\r\n        while (zoom >= 0 && (oldGrid.x !== newGrid.x || oldGrid.y !== newGrid.y)) {\r\n            const cell = this._getGridCellNoCreate(oldGrid.x, oldGrid.y, zoom);\r\n            if (cell) {\r\n                if (this._removeMarkerFromCell(cell, marker)) {\r\n                    this._getGridCellCreate(newGrid.x, newGrid.y, zoom).push(marker);\r\n                }\r\n            }\r\n            // For the current zoom we also need to update the map. Markers that no\r\n            // longer are visible are removed from the map. Markers that moved into\r\n            // the shown bounds are added to the map. This also lets us keep the count\r\n            // of visible markers up to date.\r\n            if (zoom === this._mapZoom) {\r\n                if (this._isGridPointVisible(oldGrid)) {\r\n                    if (!this._isGridPointVisible(newGrid)) {\r\n                        this._removeOverlay(marker);\r\n                        changed = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (this._isGridPointVisible(newGrid)) {\r\n                        this._addOverlay(marker);\r\n                        changed = true;\r\n                    }\r\n                }\r\n            }\r\n            oldGrid.x = oldGrid.x >> 1;\r\n            oldGrid.y = oldGrid.y >> 1;\r\n            newGrid.x = newGrid.x >> 1;\r\n            newGrid.y = newGrid.y >> 1;\r\n            --zoom;\r\n        }\r\n        if (changed) {\r\n            this._notifyListeners();\r\n        }\r\n    }\r\n    /**\r\n     * Removes marker from the manager and from the map\r\n     * (if it's currently visible).\r\n     * @param {GMarker} marker The marker to delete.\r\n     */\r\n    removeMarker(marker) {\r\n        let zoom = this._maxZoom;\r\n        let changed = false;\r\n        const point = marker.getPosition();\r\n        const grid = this._getTilePoint(point, zoom, new google.maps.Size(0, 0));\r\n        while (zoom >= 0) {\r\n            const cell = this._getGridCellNoCreate(grid.x, grid.y, zoom);\r\n            if (cell) {\r\n                this._removeMarkerFromCell(cell, marker);\r\n            }\r\n            // For the current zoom we also need to update the map. Markers that no\r\n            // longer are visible are removed from the map. This also lets us keep the count\r\n            // of visible markers up to date.\r\n            if (zoom === this._mapZoom) {\r\n                if (this._isGridPointVisible(grid)) {\r\n                    this._removeOverlay(marker);\r\n                    changed = true;\r\n                }\r\n            }\r\n            grid.x = grid.x >> 1;\r\n            grid.y = grid.y >> 1;\r\n            --zoom;\r\n        }\r\n        if (changed) {\r\n            this._notifyListeners();\r\n        }\r\n        this._numMarkers[marker.get(\"__minZoom\")]--;\r\n    }\r\n    /**\r\n     * Add many markers at once.\r\n     * Does not actually update the map, just the internal grid.\r\n     *\r\n     * @param {Array of Marker} markers The markers to add.\r\n     * @param {Number} minZoom The minimum zoom level to display the markers.\r\n     * @param {Number} maxZoom The maximum zoom level to display the markers.\r\n     */\r\n    addMarkers(markers, minZoom, maxZoom) {\r\n        maxZoom = this._getOptmaxZoom(maxZoom);\r\n        for (let i = markers.length - 1; i >= 0; i--) {\r\n            this._addMarkerBatch(markers[i], minZoom, maxZoom);\r\n        }\r\n        this._numMarkers[minZoom] += markers.length;\r\n    }\r\n    /**\r\n     * Returns the value of the optional maximum zoom. This method is defined so\r\n     * that we have just one place where optional maximum zoom is calculated.\r\n     *\r\n     * @param {Number} maxZoom The optinal maximum zoom.\r\n     * @return The maximum zoom.\r\n     */\r\n    _getOptmaxZoom(maxZoom) {\r\n        return maxZoom || this._maxZoom;\r\n    }\r\n    /**\r\n     * Calculates the total number of markers potentially visible at a given\r\n     * zoom level.\r\n     *\r\n     * @param {Number} zoom The zoom level to check.\r\n     */\r\n    getMarkerCount(zoom) {\r\n        let total = 0;\r\n        for (let z = 0; z <= zoom; z++) {\r\n            total += this._numMarkers[z];\r\n        }\r\n        return total;\r\n    }\r\n    /**\r\n     * Returns a marker given latitude, longitude and zoom. If the marker does not\r\n     * exist, the method will return a new marker. If a new marker is created,\r\n     * it will NOT be added to the manager.\r\n     *\r\n     * @param {Number} lat - the latitude of a marker.\r\n     * @param {Number} lng - the longitude of a marker.\r\n     * @param {Number} zoom - the zoom level\r\n     * @return {GMarker} marker - the marker found at lat and lng\r\n     */\r\n    getMarker(lat, lng, zoom) {\r\n        const mPoint = new google.maps.LatLng(lat, lng);\r\n        const gridPoint = this._getTilePoint(mPoint, zoom, new google.maps.Size(0, 0));\r\n        let marker = new google.maps.Marker({ position: mPoint });\r\n        const cell = this._getGridCellNoCreate(gridPoint.x, gridPoint.y, zoom);\r\n        if (cell !== undefined) {\r\n            for (let i = 0; i < cell.length; i++) {\r\n                if (lat === cell[i].getPosition().lat() &&\r\n                    lng === cell[i].getPosition().lng()) {\r\n                    marker = cell[i];\r\n                }\r\n            }\r\n        }\r\n        return marker;\r\n    }\r\n    /**\r\n     * Add a single marker to the map.\r\n     *\r\n     * @param {Marker} marker The marker to add.\r\n     * @param {Number} minZoom The minimum zoom level to display the marker.\r\n     * @param {Number} maxZoom The maximum zoom level to display the marker.\r\n     */\r\n    addMarker(marker, minZoom, maxZoom) {\r\n        maxZoom = this._getOptmaxZoom(maxZoom);\r\n        this._addMarkerBatch(marker, minZoom, maxZoom);\r\n        const gridPoint = this._getTilePoint(marker.getPosition(), this._mapZoom, new google.maps.Size(0, 0));\r\n        if (this._isGridPointVisible(gridPoint) &&\r\n            minZoom <= this._shownBounds.z &&\r\n            this._shownBounds.z <= maxZoom) {\r\n            this._addOverlay(marker);\r\n            this._notifyListeners();\r\n        }\r\n        this._numMarkers[minZoom]++;\r\n    }\r\n    /**\r\n     * Get a cell in the grid, creating it first if necessary.\r\n     *\r\n     * Optimization candidate\r\n     *\r\n     * @param {Number} x The x coordinate of the cell.\r\n     * @param {Number} y The y coordinate of the cell.\r\n     * @param {Number} z The z coordinate of the cell.\r\n     * @return {Array} The cell in the array.\r\n     */\r\n    _getGridCellCreate(x, y, z) {\r\n        // TODO(jpoehnelt) document this\r\n        if (x < 0) {\r\n            x += this._gridWidth[z];\r\n        }\r\n        if (!this._grid[z]) {\r\n            this._grid[z] = [];\r\n        }\r\n        if (!this._grid[z][x]) {\r\n            this._grid[z][x] = [];\r\n        }\r\n        if (!this._grid[z][x][y]) {\r\n            this._grid[z][x][y] = [];\r\n        }\r\n        return this._grid[z][x][y];\r\n    }\r\n    /**\r\n     * Get a cell in the grid, returning undefined if it does not exist.\r\n     *\r\n     * NOTE: Optimized for speed -- otherwise could combine with _getGridCellCreate.\r\n     *\r\n     * @param {Number} x The x coordinate of the cell.\r\n     * @param {Number} y The y coordinate of the cell.\r\n     * @param {Number} z The z coordinate of the cell.\r\n     * @return {Array} The cell in the array.\r\n     */\r\n    _getGridCellNoCreate(x, y, z) {\r\n        if (x < 0) {\r\n            x += this._gridWidth[z];\r\n        }\r\n        if (!this._grid[z]) {\r\n            return null;\r\n        }\r\n        if (!this._grid[z][x]) {\r\n            return null;\r\n        }\r\n        if (!this._grid[z][x][y]) {\r\n            return null;\r\n        }\r\n        return this._grid[z][x][y];\r\n    }\r\n    /**\r\n     * Turns at geographical bounds into a grid-space bounds.\r\n     *\r\n     * @param {LatLngBounds} bounds The geographical bounds.\r\n     * @param {Number} zoom The zoom level of the bounds.\r\n     * @param {google.maps.Size} swPadding The padding in pixels to extend beyond the\r\n     * given bounds.\r\n     * @param {google.maps.Size} nePadding The padding in pixels to extend beyond the\r\n     * given bounds.\r\n     * @return {GridBounds} The bounds in grid space.\r\n     */\r\n    _getGridBounds(bounds, zoom, swPadding, nePadding) {\r\n        zoom = Math.min(zoom, this._maxZoom);\r\n        const bl = bounds.getSouthWest();\r\n        const tr = bounds.getNorthEast();\r\n        const sw = this._getTilePoint(bl, zoom, swPadding);\r\n        const ne = this._getTilePoint(tr, zoom, nePadding);\r\n        const gw = this._gridWidth[zoom];\r\n        // Crossing the prime meridian requires correction of bounds.\r\n        if (tr.lng() < bl.lng() || ne.x < sw.x) {\r\n            sw.x -= gw;\r\n        }\r\n        if (ne.x - sw.x + 1 >= gw) {\r\n            // Computed grid bounds are larger than the world; truncate.\r\n            sw.x = 0;\r\n            ne.x = gw - 1;\r\n        }\r\n        const gridBounds = new GridBounds([sw, ne], zoom);\r\n        gridBounds.z = zoom;\r\n        return gridBounds;\r\n    }\r\n    /**\r\n     * Gets the grid-space bounds for the current map viewport.\r\n     *\r\n     * @return {Bounds} The bounds in grid space.\r\n     */\r\n    _getMapGridBounds() {\r\n        return this._getGridBounds(this._map.getBounds(), this._mapZoom, this._swPadding, this._nePadding);\r\n    }\r\n    /**\r\n     * Event listener for map:movend.\r\n     * NOTE: Use a timeout so that the user is not blocked\r\n     * from moving the map.\r\n     *\r\n     * Removed this because a a lack of a scopy override/callback function on events.\r\n     */\r\n    _onMapMoveEnd() {\r\n        window.setTimeout(this._updateMarkers.bind(this), 0);\r\n    }\r\n    /**\r\n     * Is this layer visible?\r\n     *\r\n     * Returns visibility setting\r\n     *\r\n     * @return {Boolean} Visible\r\n     */\r\n    visible() {\r\n        return this.shown ? true : false;\r\n    }\r\n    /**\r\n     * Returns true if the manager is hidden.\r\n     * Otherwise returns false.\r\n     * @return {Boolean} Hidden\r\n     */\r\n    isHidden() {\r\n        return !this.shown;\r\n    }\r\n    /**\r\n     * Shows the manager if it's currently hidden.\r\n     */\r\n    show() {\r\n        this.shown = true;\r\n        this.refresh();\r\n    }\r\n    /**\r\n     * Hides the manager if it's currently visible\r\n     */\r\n    hide() {\r\n        this.shown = false;\r\n        this.refresh();\r\n    }\r\n    /**\r\n     * Toggles the visibility of the manager.\r\n     */\r\n    toggle() {\r\n        this.shown = !this.shown;\r\n        this.refresh();\r\n    }\r\n    /**\r\n     * Refresh forces the marker-manager into a good state.\r\n     * <ol>\r\n     *   <li>If never before initialized, shows all the markers.</li>\r\n     *   <li>If previously initialized, removes and re-adds all markers.</li>\r\n     * </ol>\r\n     */\r\n    refresh() {\r\n        if (this.shownMarkers > 0) {\r\n            this._processAll(this._shownBounds, this._removeOverlay.bind(this));\r\n        }\r\n        // An extra check on this.show to increase performance (no need to _processAll_)\r\n        if (this.show) {\r\n            this._processAll(this._shownBounds, this._addOverlay.bind(this));\r\n        }\r\n        this._notifyListeners();\r\n    }\r\n    /**\r\n     * After the viewport may have changed, add or remove markers as needed.\r\n     */\r\n    _updateMarkers() {\r\n        this._mapZoom = this._map.getZoom();\r\n        const newBounds = this._getMapGridBounds();\r\n        // If the move does not include new grid sections,\r\n        // we have no work to do:\r\n        if (newBounds.equals(this._shownBounds) &&\r\n            newBounds.z === this._shownBounds.z) {\r\n            return;\r\n        }\r\n        if (newBounds.z !== this._shownBounds.z) {\r\n            this._processAll(this._shownBounds, this._removeOverlay.bind(this));\r\n            if (this.show) {\r\n                // performance\r\n                this._processAll(newBounds, this._addOverlay.bind(this));\r\n            }\r\n        }\r\n        else {\r\n            // Remove markers:\r\n            this._rectangleDiff(this._shownBounds, newBounds, this._removeCellMarkers.bind(this));\r\n            // Add markers:\r\n            if (this.show) {\r\n                // performance\r\n                this._rectangleDiff(newBounds, this._shownBounds, this._addCellMarkers.bind(this));\r\n            }\r\n        }\r\n        this._shownBounds = newBounds;\r\n        this._notifyListeners();\r\n    }\r\n    /**\r\n     * Notify listeners when the state of what is displayed changes.\r\n     */\r\n    _notifyListeners() {\r\n        google.maps.event.trigger(this, \"changed\", this._shownBounds, this.shownMarkers);\r\n    }\r\n    /**\r\n     * Process all markers in the bounds provided, using a callback.\r\n     *\r\n     * @param {Bounds} bounds The bounds in grid space.\r\n     * @param {Function} callback The function to call for each marker.\r\n     */\r\n    _processAll(bounds, callback) {\r\n        for (let x = bounds.minX; x <= bounds.maxX; x++) {\r\n            for (let y = bounds.minY; y <= bounds.maxY; y++) {\r\n                this._processCellMarkers(x, y, bounds.z, callback);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Process all markers in the grid cell, using a callback.\r\n     *\r\n     * @param {Number} x The x coordinate of the cell.\r\n     * @param {Number} y The y coordinate of the cell.\r\n     * @param {Number} z The z coordinate of the cell.\r\n     * @param {Function} callback The function to call for each marker.\r\n     */\r\n    _processCellMarkers(x, y, z, callback) {\r\n        const cell = this._getGridCellNoCreate(x, y, z);\r\n        if (cell) {\r\n            for (let i = cell.length - 1; i >= 0; i--) {\r\n                callback(cell[i]);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Remove all markers in a grid cell.\r\n     *\r\n     * @param {Number} x The x coordinate of the cell.\r\n     * @param {Number} y The y coordinate of the cell.\r\n     * @param {Number} z The z coordinate of the cell.\r\n     */\r\n    _removeCellMarkers(x, y, z) {\r\n        this._processCellMarkers(x, y, z, this._removeOverlay.bind(this));\r\n    }\r\n    /**\r\n     * Add all markers in a grid cell.\r\n     *\r\n     * @param {Number} x The x coordinate of the cell.\r\n     * @param {Number} y The y coordinate of the cell.\r\n     * @param {Number} z The z coordinate of the cell.\r\n     */\r\n    _addCellMarkers(x, y, z) {\r\n        this._processCellMarkers(x, y, z, this._addOverlay.bind(this));\r\n    }\r\n    /**\r\n     * Use the _rectangleDiffCoords function to process all grid cells\r\n     * that are in bounds1 but not bounds2, using a callback, and using\r\n     * the current MarkerManager object as the instance.\r\n     *\r\n     * Pass the z parameter to the callback in addition to x and y.\r\n     *\r\n     * @param {Bounds} bounds1 The bounds of all points we may _process.\r\n     * @param {Bounds} bounds2 The bounds of points to exclude.\r\n     * @param {Function} callback The callback function to call\r\n     *                   for each grid coordinate (x, y, z).\r\n     */\r\n    _rectangleDiff(bounds1, bounds2, callback) {\r\n        this._rectangleDiffCoords(bounds1, bounds2, function (x, y) {\r\n            callback(x, y, bounds1.z);\r\n        });\r\n    }\r\n    /**\r\n     * Calls the function for all points in bounds1, not in bounds2\r\n     *\r\n     * @param {Bounds} bounds1 The bounds of all points we may process.\r\n     * @param {Bounds} bounds2 The bounds of points to exclude.\r\n     * @param {Function} callback The callback function to call\r\n     *                   for each grid coordinate.\r\n     */\r\n    _rectangleDiffCoords(bounds1, bounds2, callback) {\r\n        const minX1 = bounds1.minX;\r\n        const minY1 = bounds1.minY;\r\n        const maxX1 = bounds1.maxX;\r\n        const maxY1 = bounds1.maxY;\r\n        const minX2 = bounds2.minX;\r\n        const minY2 = bounds2.minY;\r\n        const maxX2 = bounds2.maxX;\r\n        const maxY2 = bounds2.maxY;\r\n        let x, y;\r\n        for (x = minX1; x <= maxX1; x++) {\r\n            // All x in R1\r\n            // All above:\r\n            for (y = minY1; y <= maxY1 && y < minY2; y++) {\r\n                // y in R1 above R2\r\n                callback(x, y);\r\n            }\r\n            // All below:\r\n            for (y = Math.max(maxY2 + 1, minY1); // y in R1 below R2\r\n             y <= maxY1; y++) {\r\n                callback(x, y);\r\n            }\r\n        }\r\n        for (y = Math.max(minY1, minY2); y <= Math.min(maxY1, maxY2); y++) {\r\n            // All y in R2 and in R1\r\n            // Strictly left:\r\n            for (x = Math.min(maxX1 + 1, minX2) - 1; x >= minX1; x--) {\r\n                // x in R1 left of R2\r\n                callback(x, y);\r\n            }\r\n            // Strictly right:\r\n            for (x = Math.max(minX1, maxX2 + 1); // x in R1 right of R2\r\n             x <= maxX1; x++) {\r\n                callback(x, y);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Removes marker from cell. O(N).\r\n     */\r\n    _removeMarkerFromCell(cell, marker) {\r\n        let shift = 0;\r\n        for (let i = 0; i < cell.length; ++i) {\r\n            if (cell[i] === marker) {\r\n                cell.splice(i--, 1);\r\n                shift++;\r\n            }\r\n        }\r\n        return shift;\r\n    }\r\n}\r\nexport { MarkerManager };\r\n//# sourceMappingURL=markermanager.js.map","references":["/home/travis/build/googlemaps/v3-utility-library/packages/markermanager/src/utils.ts","/home/travis/build/googlemaps/v3-utility-library/packages/markermanager/src/gridbounds.ts"],"map":"{\"version\":3,\"file\":\"markermanager.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../src/markermanager.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/travis/build/googlemaps/v3-utility-library/packages/markermanager/markermanager.d.ts","writeByteOrderMark":false,"text":"/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/// <reference types=\"@types/googlemaps\" />\r\ninterface Options {\r\n    maxZoom?: number;\r\n    shown?: boolean;\r\n    trackMarkers?: boolean;\r\n    borderPadding?: number;\r\n}\r\n/**\r\n * Creates a new MarkerManager that will show/hide markers on a map.\r\n */\r\ndeclare class MarkerManager {\r\n    shown: boolean;\r\n    shownMarkers: number;\r\n    private _map;\r\n    private _mapZoom;\r\n    private _maxZoom;\r\n    private _tileSize;\r\n    private _trackMarkers;\r\n    private _swPadding;\r\n    private _nePadding;\r\n    private _gridWidth;\r\n    private _grid;\r\n    private _numMarkers;\r\n    private _shownBounds;\r\n    /**\r\n     * @constructor\r\n     * @param map The map to manage.\r\n     * @param {Options} options\r\n     */\r\n    constructor(map: google.maps.Map, { maxZoom, trackMarkers, shown, borderPadding }: Options);\r\n    private _initialize;\r\n    /**\r\n     * This closure provide easy access to the map.\r\n     * They are used as callbacks, not as methods.\r\n     * @param marker Marker to be removed from the map\r\n     */\r\n    private _removeOverlay;\r\n    /**\r\n     * This closure provide easy access to the map.\r\n     * They are used as callbacks, not as methods.\r\n     * @param marker Marker to be added to the map\r\n     */\r\n    private _addOverlay;\r\n    /**\r\n     * Initializes MarkerManager arrays for all zoom levels\r\n     * Called by constructor and by clearAllMarkers\r\n     */\r\n    resetManager(): void;\r\n    /**\r\n     * Removes all markers in the manager, and\r\n     * removes any visible markers from the map.\r\n     */\r\n    clearMarkers(): void;\r\n    /**\r\n     * Gets the tile coordinate for a given latlng point.\r\n     *\r\n     * @param {LatLng} latlng The geographical point.\r\n     * @param {Number} zoom The zoom level.\r\n     * @param {google.maps.Size} padding The padding used to shift the pixel coordinate.\r\n     *               Used for expanding a bounds to include an extra padding\r\n     *               of pixels surrounding the bounds.\r\n     * @return {GPoint} The point in tile coordinates.\r\n     *\r\n     */\r\n    private _getTilePoint;\r\n    /**\r\n     * Finds the appropriate place to add the marker to the grid.\r\n     * Optimized for speed; does not actually add the marker to the map.\r\n     * Designed for batch-_processing thousands of markers.\r\n     *\r\n     * @param {Marker} marker The marker to add.\r\n     * @param {Number} minZoom The minimum zoom for displaying the marker.\r\n     * @param {Number} maxZoom The maximum zoom for displaying the marker.\r\n     */\r\n    private _addMarkerBatch;\r\n    /**\r\n     * Returns whether or not the given point is visible in the shown bounds. This\r\n     * is a helper method that takes care of the corner case, when shownBounds have\r\n     * negative minX value.\r\n     *\r\n     * @param {Point} point a point on a grid.\r\n     * @return {Boolean} Whether or not the given point is visible in the currently\r\n     * shown bounds.\r\n     */\r\n    private _isGridPointVisible;\r\n    /**\r\n     * Reacts to a notification from a marker that it has moved to a new location.\r\n     * It scans the grid all all zoom levels and moves the marker from the old grid\r\n     * location to a new grid location.\r\n     *\r\n     * @param {Marker} marker The marker that moved.\r\n     * @param {LatLng} oldPoint The old position of the marker.\r\n     * @param {LatLng} newPoint The new position of the marker.\r\n     */\r\n    private _onMarkerMoved;\r\n    /**\r\n     * Removes marker from the manager and from the map\r\n     * (if it's currently visible).\r\n     * @param {GMarker} marker The marker to delete.\r\n     */\r\n    removeMarker(marker: google.maps.Marker): void;\r\n    /**\r\n     * Add many markers at once.\r\n     * Does not actually update the map, just the internal grid.\r\n     *\r\n     * @param {Array of Marker} markers The markers to add.\r\n     * @param {Number} minZoom The minimum zoom level to display the markers.\r\n     * @param {Number} maxZoom The maximum zoom level to display the markers.\r\n     */\r\n    addMarkers(markers: google.maps.Marker[], minZoom: number, maxZoom: number): void;\r\n    /**\r\n     * Returns the value of the optional maximum zoom. This method is defined so\r\n     * that we have just one place where optional maximum zoom is calculated.\r\n     *\r\n     * @param {Number} maxZoom The optinal maximum zoom.\r\n     * @return The maximum zoom.\r\n     */\r\n    private _getOptmaxZoom;\r\n    /**\r\n     * Calculates the total number of markers potentially visible at a given\r\n     * zoom level.\r\n     *\r\n     * @param {Number} zoom The zoom level to check.\r\n     */\r\n    getMarkerCount(zoom: number): number;\r\n    /**\r\n     * Returns a marker given latitude, longitude and zoom. If the marker does not\r\n     * exist, the method will return a new marker. If a new marker is created,\r\n     * it will NOT be added to the manager.\r\n     *\r\n     * @param {Number} lat - the latitude of a marker.\r\n     * @param {Number} lng - the longitude of a marker.\r\n     * @param {Number} zoom - the zoom level\r\n     * @return {GMarker} marker - the marker found at lat and lng\r\n     */\r\n    getMarker(lat: number, lng: number, zoom: number): google.maps.Marker;\r\n    /**\r\n     * Add a single marker to the map.\r\n     *\r\n     * @param {Marker} marker The marker to add.\r\n     * @param {Number} minZoom The minimum zoom level to display the marker.\r\n     * @param {Number} maxZoom The maximum zoom level to display the marker.\r\n     */\r\n    addMarker(marker: google.maps.Marker, minZoom: number, maxZoom: number): void;\r\n    /**\r\n     * Get a cell in the grid, creating it first if necessary.\r\n     *\r\n     * Optimization candidate\r\n     *\r\n     * @param {Number} x The x coordinate of the cell.\r\n     * @param {Number} y The y coordinate of the cell.\r\n     * @param {Number} z The z coordinate of the cell.\r\n     * @return {Array} The cell in the array.\r\n     */\r\n    private _getGridCellCreate;\r\n    /**\r\n     * Get a cell in the grid, returning undefined if it does not exist.\r\n     *\r\n     * NOTE: Optimized for speed -- otherwise could combine with _getGridCellCreate.\r\n     *\r\n     * @param {Number} x The x coordinate of the cell.\r\n     * @param {Number} y The y coordinate of the cell.\r\n     * @param {Number} z The z coordinate of the cell.\r\n     * @return {Array} The cell in the array.\r\n     */\r\n    private _getGridCellNoCreate;\r\n    /**\r\n     * Turns at geographical bounds into a grid-space bounds.\r\n     *\r\n     * @param {LatLngBounds} bounds The geographical bounds.\r\n     * @param {Number} zoom The zoom level of the bounds.\r\n     * @param {google.maps.Size} swPadding The padding in pixels to extend beyond the\r\n     * given bounds.\r\n     * @param {google.maps.Size} nePadding The padding in pixels to extend beyond the\r\n     * given bounds.\r\n     * @return {GridBounds} The bounds in grid space.\r\n     */\r\n    private _getGridBounds;\r\n    /**\r\n     * Gets the grid-space bounds for the current map viewport.\r\n     *\r\n     * @return {Bounds} The bounds in grid space.\r\n     */\r\n    private _getMapGridBounds;\r\n    /**\r\n     * Event listener for map:movend.\r\n     * NOTE: Use a timeout so that the user is not blocked\r\n     * from moving the map.\r\n     *\r\n     * Removed this because a a lack of a scopy override/callback function on events.\r\n     */\r\n    private _onMapMoveEnd;\r\n    /**\r\n     * Is this layer visible?\r\n     *\r\n     * Returns visibility setting\r\n     *\r\n     * @return {Boolean} Visible\r\n     */\r\n    visible(): boolean;\r\n    /**\r\n     * Returns true if the manager is hidden.\r\n     * Otherwise returns false.\r\n     * @return {Boolean} Hidden\r\n     */\r\n    isHidden(): boolean;\r\n    /**\r\n     * Shows the manager if it's currently hidden.\r\n     */\r\n    show(): void;\r\n    /**\r\n     * Hides the manager if it's currently visible\r\n     */\r\n    hide(): void;\r\n    /**\r\n     * Toggles the visibility of the manager.\r\n     */\r\n    toggle(): void;\r\n    /**\r\n     * Refresh forces the marker-manager into a good state.\r\n     * <ol>\r\n     *   <li>If never before initialized, shows all the markers.</li>\r\n     *   <li>If previously initialized, removes and re-adds all markers.</li>\r\n     * </ol>\r\n     */\r\n    refresh(): void;\r\n    /**\r\n     * After the viewport may have changed, add or remove markers as needed.\r\n     */\r\n    private _updateMarkers;\r\n    /**\r\n     * Notify listeners when the state of what is displayed changes.\r\n     */\r\n    private _notifyListeners;\r\n    /**\r\n     * Process all markers in the bounds provided, using a callback.\r\n     *\r\n     * @param {Bounds} bounds The bounds in grid space.\r\n     * @param {Function} callback The function to call for each marker.\r\n     */\r\n    private _processAll;\r\n    /**\r\n     * Process all markers in the grid cell, using a callback.\r\n     *\r\n     * @param {Number} x The x coordinate of the cell.\r\n     * @param {Number} y The y coordinate of the cell.\r\n     * @param {Number} z The z coordinate of the cell.\r\n     * @param {Function} callback The function to call for each marker.\r\n     */\r\n    private _processCellMarkers;\r\n    /**\r\n     * Remove all markers in a grid cell.\r\n     *\r\n     * @param {Number} x The x coordinate of the cell.\r\n     * @param {Number} y The y coordinate of the cell.\r\n     * @param {Number} z The z coordinate of the cell.\r\n     */\r\n    private _removeCellMarkers;\r\n    /**\r\n     * Add all markers in a grid cell.\r\n     *\r\n     * @param {Number} x The x coordinate of the cell.\r\n     * @param {Number} y The y coordinate of the cell.\r\n     * @param {Number} z The z coordinate of the cell.\r\n     */\r\n    private _addCellMarkers;\r\n    /**\r\n     * Use the _rectangleDiffCoords function to process all grid cells\r\n     * that are in bounds1 but not bounds2, using a callback, and using\r\n     * the current MarkerManager object as the instance.\r\n     *\r\n     * Pass the z parameter to the callback in addition to x and y.\r\n     *\r\n     * @param {Bounds} bounds1 The bounds of all points we may _process.\r\n     * @param {Bounds} bounds2 The bounds of points to exclude.\r\n     * @param {Function} callback The callback function to call\r\n     *                   for each grid coordinate (x, y, z).\r\n     */\r\n    private _rectangleDiff;\r\n    /**\r\n     * Calls the function for all points in bounds1, not in bounds2\r\n     *\r\n     * @param {Bounds} bounds1 The bounds of all points we may process.\r\n     * @param {Bounds} bounds2 The bounds of points to exclude.\r\n     * @param {Function} callback The callback function to call\r\n     *                   for each grid coordinate.\r\n     */\r\n    private _rectangleDiffCoords;\r\n    /**\r\n     * Removes marker from cell. O(N).\r\n     */\r\n    private _removeMarkerFromCell;\r\n}\r\nexport { MarkerManager };\r\n"}}
