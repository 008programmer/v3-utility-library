{"code":"/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { ClusterIcon } from \"./cluster-icon\";\r\n/**\r\n * Creates a single cluster that manages a group of proximate markers.\r\n *  Used internally, do not call this constructor directly.\r\n */\r\nexport class Cluster {\r\n    /**\r\n     *\r\n     * @param markerClusterer_ The `MarkerClusterer` object with which this\r\n     *  cluster is associated.\r\n     */\r\n    constructor(markerClusterer_) {\r\n        this.markerClusterer_ = markerClusterer_;\r\n        this.map_ = this.markerClusterer_.getMap();\r\n        this.minClusterSize_ = this.markerClusterer_.getMinimumClusterSize();\r\n        this.averageCenter_ = this.markerClusterer_.getAverageCenter();\r\n        this.markers_ = []; // TODO: type;\r\n        this.center_ = null;\r\n        this.bounds_ = null;\r\n        this.clusterIcon_ = new ClusterIcon(this, this.markerClusterer_.getStyles());\r\n    }\r\n    /**\r\n     * Returns the number of markers managed by the cluster. You can call this from\r\n     * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\r\n     *\r\n     * @return The number of markers in the cluster.\r\n     */\r\n    getSize() {\r\n        return this.markers_.length;\r\n    }\r\n    /**\r\n     * Returns the array of markers managed by the cluster. You can call this from\r\n     * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\r\n     *\r\n     * @return The array of markers in the cluster.\r\n     */\r\n    getMarkers() {\r\n        return this.markers_;\r\n    }\r\n    /**\r\n     * Returns the center of the cluster. You can call this from\r\n     * a `click`, `mouseover`, or `mouseout` event handler\r\n     * for the `MarkerClusterer` object.\r\n     *\r\n     * @return The center of the cluster.\r\n     */\r\n    getCenter() {\r\n        return this.center_;\r\n    }\r\n    /**\r\n     * Returns the map with which the cluster is associated.\r\n     *\r\n     * @return The map.\r\n     * @ignore\r\n     */\r\n    getMap() {\r\n        return this.map_;\r\n    }\r\n    /**\r\n     * Returns the `MarkerClusterer` object with which the cluster is associated.\r\n     *\r\n     * @return The associated marker clusterer.\r\n     * @ignore\r\n     */\r\n    getMarkerClusterer() {\r\n        return this.markerClusterer_;\r\n    }\r\n    /**\r\n     * Returns the bounds of the cluster.\r\n     *\r\n     * @return the cluster bounds.\r\n     * @ignore\r\n     */\r\n    getBounds() {\r\n        const bounds = new google.maps.LatLngBounds(this.center_, this.center_);\r\n        const markers = this.getMarkers();\r\n        for (let i = 0; i < markers.length; i++) {\r\n            bounds.extend(markers[i].getPosition());\r\n        }\r\n        return bounds;\r\n    }\r\n    /**\r\n     * Removes the cluster from the map.\r\n     *\r\n     * @ignore\r\n     */\r\n    remove() {\r\n        this.clusterIcon_.setMap(null);\r\n        this.markers_ = [];\r\n        delete this.markers_;\r\n    }\r\n    /**\r\n     * Adds a marker to the cluster.\r\n     *\r\n     * @param marker The marker to be added.\r\n     * @return True if the marker was added.\r\n     * @ignore\r\n     */\r\n    addMarker(marker) {\r\n        if (this.isMarkerAlreadyAdded_(marker)) {\r\n            return false;\r\n        }\r\n        if (!this.center_) {\r\n            this.center_ = marker.getPosition();\r\n            this.calculateBounds_();\r\n        }\r\n        else {\r\n            if (this.averageCenter_) {\r\n                const l = this.markers_.length + 1;\r\n                const lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;\r\n                const lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;\r\n                this.center_ = new google.maps.LatLng(lat, lng);\r\n                this.calculateBounds_();\r\n            }\r\n        }\r\n        marker.isAdded = true;\r\n        this.markers_.push(marker);\r\n        const mCount = this.markers_.length;\r\n        const mz = this.markerClusterer_.getMaxZoom();\r\n        if (mz !== null && this.map_.getZoom() > mz) {\r\n            // Zoomed in past max zoom, so show the marker.\r\n            if (marker.getMap() !== this.map_) {\r\n                marker.setMap(this.map_);\r\n            }\r\n        }\r\n        else if (mCount < this.minClusterSize_) {\r\n            // Min cluster size not reached so show the marker.\r\n            if (marker.getMap() !== this.map_) {\r\n                marker.setMap(this.map_);\r\n            }\r\n        }\r\n        else if (mCount === this.minClusterSize_) {\r\n            // Hide the markers that were showing.\r\n            for (let i = 0; i < mCount; i++) {\r\n                this.markers_[i].setMap(null);\r\n            }\r\n        }\r\n        else {\r\n            marker.setMap(null);\r\n        }\r\n        this.updateIcon_();\r\n        return true;\r\n    }\r\n    /**\r\n     * Determines if a marker lies within the cluster's bounds.\r\n     *\r\n     * @param marker The marker to check.\r\n     * @return True if the marker lies in the bounds.\r\n     * @ignore\r\n     */\r\n    isMarkerInClusterBounds(marker) {\r\n        return this.bounds_.contains(marker.getPosition());\r\n    }\r\n    /**\r\n     * Calculates the extended bounds of the cluster with the grid.\r\n     */\r\n    calculateBounds_() {\r\n        const bounds = new google.maps.LatLngBounds(this.center_, this.center_);\r\n        this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\r\n    }\r\n    /**\r\n     * Updates the cluster icon.\r\n     */\r\n    updateIcon_() {\r\n        const mCount = this.markers_.length;\r\n        const mz = this.markerClusterer_.getMaxZoom();\r\n        if (mz !== null && this.map_.getZoom() > mz) {\r\n            this.clusterIcon_.hide();\r\n            return;\r\n        }\r\n        if (mCount < this.minClusterSize_) {\r\n            // Min cluster size not yet reached.\r\n            this.clusterIcon_.hide();\r\n            return;\r\n        }\r\n        const numStyles = this.markerClusterer_.getStyles().length;\r\n        const sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\r\n        this.clusterIcon_.setCenter(this.center_);\r\n        this.clusterIcon_.useStyle(sums);\r\n        this.clusterIcon_.show();\r\n    }\r\n    /**\r\n     * Determines if a marker has already been added to the cluster.\r\n     *\r\n     * @param marker The marker to check.\r\n     * @return True if the marker has already been added.\r\n     */\r\n    isMarkerAlreadyAdded_(marker) {\r\n        if (this.markers_.indexOf) {\r\n            return this.markers_.indexOf(marker) !== -1;\r\n        }\r\n        else {\r\n            for (let i = 0; i < this.markers_.length; i++) {\r\n                if (marker === this.markers_[i]) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n//# sourceMappingURL=cluster.js.map","references":["/home/travis/build/googlemaps/v3-utility-library/packages/markerclustererplus/src/markerclusterer.ts","/home/travis/build/googlemaps/v3-utility-library/packages/markerclustererplus/src/cluster-icon.ts"],"map":"{\"version\":3,\"file\":\"cluster.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../src/cluster.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/travis/build/googlemaps/v3-utility-library/packages/markerclustererplus/cluster.d.ts","writeByteOrderMark":false,"text":"/**\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/// <reference types=\"googlemaps\" />\r\nimport { MarkerClusterer } from \"./markerclusterer\";\r\n/**\r\n * Creates a single cluster that manages a group of proximate markers.\r\n *  Used internally, do not call this constructor directly.\r\n */\r\nexport declare class Cluster {\r\n    private markerClusterer_;\r\n    private map_;\r\n    private minClusterSize_;\r\n    private averageCenter_;\r\n    private markers_;\r\n    private center_;\r\n    private bounds_;\r\n    private clusterIcon_;\r\n    /**\r\n     *\r\n     * @param markerClusterer_ The `MarkerClusterer` object with which this\r\n     *  cluster is associated.\r\n     */\r\n    constructor(markerClusterer_: MarkerClusterer);\r\n    /**\r\n     * Returns the number of markers managed by the cluster. You can call this from\r\n     * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\r\n     *\r\n     * @return The number of markers in the cluster.\r\n     */\r\n    getSize(): number;\r\n    /**\r\n     * Returns the array of markers managed by the cluster. You can call this from\r\n     * a `click`, `mouseover`, or `mouseout` event handler for the `MarkerClusterer` object.\r\n     *\r\n     * @return The array of markers in the cluster.\r\n     */\r\n    getMarkers(): google.maps.Marker[];\r\n    /**\r\n     * Returns the center of the cluster. You can call this from\r\n     * a `click`, `mouseover`, or `mouseout` event handler\r\n     * for the `MarkerClusterer` object.\r\n     *\r\n     * @return The center of the cluster.\r\n     */\r\n    getCenter(): google.maps.LatLng;\r\n    /**\r\n     * Returns the map with which the cluster is associated.\r\n     *\r\n     * @return The map.\r\n     * @ignore\r\n     */\r\n    getMap(): google.maps.Map;\r\n    /**\r\n     * Returns the `MarkerClusterer` object with which the cluster is associated.\r\n     *\r\n     * @return The associated marker clusterer.\r\n     * @ignore\r\n     */\r\n    getMarkerClusterer(): MarkerClusterer;\r\n    /**\r\n     * Returns the bounds of the cluster.\r\n     *\r\n     * @return the cluster bounds.\r\n     * @ignore\r\n     */\r\n    getBounds(): google.maps.LatLngBounds;\r\n    /**\r\n     * Removes the cluster from the map.\r\n     *\r\n     * @ignore\r\n     */\r\n    remove(): void;\r\n    /**\r\n     * Adds a marker to the cluster.\r\n     *\r\n     * @param marker The marker to be added.\r\n     * @return True if the marker was added.\r\n     * @ignore\r\n     */\r\n    addMarker(marker: google.maps.Marker & {\r\n        isAdded?: boolean;\r\n    }): boolean;\r\n    /**\r\n     * Determines if a marker lies within the cluster's bounds.\r\n     *\r\n     * @param marker The marker to check.\r\n     * @return True if the marker lies in the bounds.\r\n     * @ignore\r\n     */\r\n    isMarkerInClusterBounds(marker: google.maps.Marker): boolean;\r\n    /**\r\n     * Calculates the extended bounds of the cluster with the grid.\r\n     */\r\n    private calculateBounds_;\r\n    /**\r\n     * Updates the cluster icon.\r\n     */\r\n    private updateIcon_;\r\n    /**\r\n     * Determines if a marker has already been added to the cluster.\r\n     *\r\n     * @param marker The marker to check.\r\n     * @return True if the marker has already been added.\r\n     */\r\n    private isMarkerAlreadyAdded_;\r\n}\r\n"}}
